#!/bin/bash
#---BOOLEAN CONSTANTS
TB_ON="on"
TB_OFF="off"

#---CHARACTER CONSTANTS
TB_BACKSPACE=$'\b'
TB_COMMA=","
TB_DASH="-"
TB_DOT="."
TB_DOTDOT=".."
TB_ENTER=$'\x0a'
TB_ESCAPEKEY=$'\x1b'
TB_SEMICOLON=";"
TB_SLASH="/"
TB_TAB=$'\t'
TB_LSQRBRACK="["
TB_RSQRBRACK="]"


#---COLOR CONSTANTS
TB_NOCOLOR=$'\e[0;0m'
TB_FG_BLUE_33=$'\e[30;38;5;33m'
TB_FG_BLUE_45=$'\e[30;38;5;45m'
TB_FG_GREEN_158=$'\e[30;38;5;158m'
TB_FG_GREY_243=$'\e[30;38;5;243m'
TB_FG_GREY_246=$'\e[30;38;5;246m'
TB_FG_ORANGE_131=$'\e[30;38;5;131m'
TB_FG_ORANGE_208=$'\e[30;38;5;208m'
TB_FG_MAIN_ORANGE_215=$'\e[30;38;5;215m'
TB_FG_RED_9=$'\e[30;38;5;9m'
TB_FG_RED_187=$'\e[30;38;5;187m'
TB_FG_YELLOW_33=$'\e[1;33m'

TB_BG_ORANGE_215=$'\e[30;48;5;215m'

#---COMMAND CONSTANTS
REBOOT_CMD="reboot now"

#---CREDENTIAL CONSTANTS
TB_USER_ROOT="root"

#---DIMENSION CONSTANTS
TB_BASENAME_COMPACT_LEN_MIN=6

TB_PERCENT_80=80
TB_TERMWINDOW_WIDTH=$(tput cols)
TB_TABLEWIDTH=$((( TB_TERMWINDOW_WIDTH * TB_PERCENT_80)/100 ))

TB_LISTPAGE_LEN=10  #Please note: TB_LISTPAGE_LEN <= 10

#---FLAG CONSTANTS
TB_BACKUPMODE_DSTDIR="backupmode dstdir"
TB_BACKUPMODE_DSTFILE="backupmode dstfile"
TB_BACKUPMODE_SRCPATH="backupmode srcpath"
TB_RESTOREMODE_DSTPATH="restoremode dstpath"
TB_RESTOREMODE_SRCFILE="restoremode srcfile"
TB_TYPE_BACKUP="backup"
TB_TYPE_RESTORE="restore"
TB_DISKSIZE_COMPARE_RESULT_INSUFFICIENT="insufficient"
TB_DISKSIZE_COMPARE_RESULT_SUFFICIENT="sufficient"

#---FUNCTION-KEY CONSTANTS
TB_FUNC_F1="F1"
TB_FUNC_F2="F2"
TB_FUNC_F3="F3"
TB_FUNC_F4="F4"
TB_FUNC_F5="F5"
TB_FUNC_F6="F6"
TB_FUNC_F7="F7"
TB_FUNC_F8="F8"
TB_FUNC_F9="F9"
TB_FUNC_F10="F10"
TB_FUNC_F12="F12"
TB_FUNC_O="O"
TB_FUNC_P="P"
TB_FUNC_Q="Q"
TB_FUNC_R="R"
TB_FUNC_S="S"
TB_FUNC_SLB="["    #square-left-bracket (SLB)
TB_FUNC_15="15"
TB_FUNC_17="17"
TB_FUNC_18="18"
TB_FUNC_19="19"
TB_FUNC_20="20"
TB_FUNC_21="21"
TB_FUNC_24="24"

#---LEGEND CONSTANTS
TB_LEGEND="${TB_FG_GREY_246}Legend:${TB_NOCOLOR}"
TB_LEGEND_SAME="="
TB_LEGEND_SAME_W_DESCRIPTION="${TB_LEGEND_SAME} : ${TB_FG_GREY_246}same${TB_NOCOLOR}"
TB_LEGEND_NEW="${TB_FG_GREEN_158}+${TB_NOCOLOR}"
TB_LEGEND_NEW_W_DESCRIPTION="${TB_LEGEND_NEW} : ${TB_FG_GREY_246}new${TB_NOCOLOR}"
TB_LEGEND_NEW_PRIORITY="${TB_LEGEND_NEW}${TB_FG_RED_9}*${TB_NOCOLOR}"
TB_LEGEND_NEW_PRIORITY_W_DESCRIPTION="${TB_LEGEND_NEW_PRIORITY}: ${TB_FG_GREY_246}new with priority${TB_NOCOLOR}"

#---MENU CONSTANTS
TB_MENUITEM_BOOTOPTIONS="One-time boot-options"
TB_MENUITEM_ISPBOOOTBIN_BOOTSEQ="ISPBOOOT.BIN boot-seq"
TB_MENUITEM_OVERLAYMODE="Overlay-mode"
TB_MODE_ISPBOOOTBIN_BOOTSEQ_SDUSB0USB1="SD>USB0>USB1"
TB_MODE_ISPBOOOTBIN_BOOTSEQ_SDUSB1USB0="SD>USB1>USB0"
TB_MODE_ISPBOOOTBIN_BOOTSEQ_USB0SDUSB1="USB0>SD>USB1"
TB_MODE_ISPBOOOTBIN_BOOTSEQ_USB0USB1SD="USB0>USB1>SD"
TB_MODE_ISPBOOOTBIN_BOOTSEQ_USB1SDUSB0="USB1>SD>USB0"
TB_MODE_ISPBOOOTBIN_BOOTSEQ_USB1USB0SD="USB1>USB0>SD"
TB_MODE_BACKUPMODE="backup-mode"
TB_MODE_CLEAN_BOOT="clean-boot"
TB_MODE_DISABLED="disabled"
TB_MODE_NORMAL_BOOT="normal-boot"
TB_MODE_RESTOREMODE="restore-mode"
# TB_MODE_SAFEMODE="safe-mode"
TB_MODE_NONPERSISTENT="non-persistent"
TB_MODE_PERSISTENT="persistent"

TB_OPTIONS_B="b"
TB_OPTIONS_C="c"
TB_OPTIONS_H="h"
TB_OPTIONS_M="m"
TB_OPTIONS_N="n"
TB_OPTIONS_R="r"
TB_OPTIONS_P="p"
TB_OPTIONS_Q="q"
TB_OPTIONS_Y="y"
TB_OPTIONS_LARROW="<"
TB_OPTIONS_RARROW=">"
TB_OPTIONS_BACK="Back"
TB_OPTIONS_CONFIRM="Confirm"
TB_OPTIONS_CLEAR="Clear"
TB_OPTIONS_HOME="Home"
TB_OPTIONS_INPUTMODE="Input-mode"
TB_OPTIONS_MAIN="Main"
TB_OPTIONS_PAGE_PREV="Prev page"
TB_OPTIONS_PAGE_NEXT="Next page"
TB_OPTIONS_REBOOT="Reboot"
TB_OPTIONS_REDO="Redo"
TB_OPTIONS_QUIT_CTRL_C="Quit (${TB_FG_GREY_246}Ctrl+C${TB_NOCOLOR})"

TB_OPTIONS_SEMICOLON_B=";b"
TB_OPTIONS_SEMICOLON_C=";c"
TB_OPTIONS_SEMICOLON_H=";h"
TB_OPTIONS_SEMICOLON_M=";m"
TB_OPTIONS_SEMICOLON_Q=";q"

TB_READDIALOG_ARE_YOU_SURE_YOU_WISH_TO_REBOOT="Are you sure you wish to reboot (y/n)? "
TB_READDIALOG_CHOOSE_AN_OPTION="Choose an option: "
TB_READDIALOG_CHOOSE_AN_OPTION_AND_C_TO_CONFIRM="Choose an option (${TB_FG_GREY_246}and press ${TB_FG_YELLOW_33}c${TB_FG_GREY_246}onfirm${TB_NOCOLOR}): "
TB_READDIALOG_CHOOSE_AN_OPTION_AND_PRESS_ENTER="Choose an option (${TB_FG_GREY_246}and press ENTER${TB_NOCOLOR}): "
TB_READDIALOG_ACCEPT_AND_CONTINUE="Accept and continue (y/n)? "
TB_READDIALOG_INPUT_FILENAME_AND_PRESS_ENTER="Input filename (${TB_FG_GREY_246}and press ENTER${TB_NOCOLOR}): "

TB_TITLE_BACKUPMODE_CHOOSE_DSTDIR="${TB_FG_MAIN_ORANGE_215}BACKUP:${TB_NOCOLOR} Choose destination-dir"
TB_TITLE_BACKUPMODE_CHOOSE_SRCDIR="${TB_FG_MAIN_ORANGE_215}BACKUP:${TB_NOCOLOR} Choose source dev-partition"
TB_TITLE_BACKUPMODE_INPUT_DSTFILE="${TB_FG_MAIN_ORANGE_215}BACKUP:${TB_NOCOLOR} Input destination-filename"
TB_TITLE_BOOTINTO="${TB_FG_BLUE_45}TB-INIT.SH: ${TB_FG_BLUE_33}ONE-TIME BOOT-OPTIONS${TB_NOCOLOR}"
TB_TITLE_ISPBOOOTBIN_BOOTSEQ="${TB_FG_BLUE_45}TB-INIT.SH: ${TB_FG_BLUE_33}ISPBOOOT.BIN BOOT-SEQ${TB_NOCOLOR}"
TB_TITLE_RESTOREMODE_CHOOSE_SRCDIR="${TB_FG_MAIN_ORANGE_215}RESTORE:${TB_NOCOLOR} Choose destination dev-partition"
TB_TITLE_RESTOREMODE_CHOOSE_SRCFILE="${TB_FG_MAIN_ORANGE_215}RESTORE:${TB_NOCOLOR} Choose source-filename"
TB_TITLE_TB_INIT_SH="${TB_FG_BLUE_45}TB-INIT.SH: ${TB_FG_BLUE_33}MAIN-MENU${TB_NOCOLOR}"
TB_TITLE_TIBBO="TIBBO"

#---NUMERIC CONSTANTS
TB_EXITCODE_99=99

TB_ITEMNUM_1=1
TB_ITEMNUM_2=2
TB_ITEMNUM_3=3
TB_ITEMNUM_4=4
TB_ITEMNUM_5=5
TB_ITEMNUM_6=6

TB_FIELDNUM_1=1
TB_FIELDNUM_2=2

TB_NUMOFLINES_0=0
TB_NUMOFLINES_1=1
TB_NUMOFLINES_2=2
TB_NUMOFLINES_3=3
TB_NUMOFLINES_4=4
TB_NUMOFLINES_5=5
TB_NUMOFLINES_6=6
TB_NUMOFLINES_7=7
TB_NUMOFLINES_8=8
TB_NUMOFLINES_9=9
TB_NUMOFLINES_10=10
TB_NUMOFLINES_11=11
TB_NUMOFLINES_12=12

TB_TRAPNUM_2=2

#---OPTION CONSTANTS
TB_NOBOOT_IS_TRUE="tb_noboot=true"
TB_ROOTFS_RO_IS_EMPTYSTRING="tb_rootfs_ro="
TB_ROOTFS_RO_IS_NULL="tb_rootfs_ro=null"
TB_ROOTFS_RO_IS_TRUE="tb_rootfs_ro=true"

#---PATTERN CONSTANTS
TB_PATTERN_LBRACKET_D_RBRACKET="[d]"
TB_PATTERN_MMCBLK0="mmcblk0"
TB_PATTERN_TB_BACKUP="tb_backup"
TB_PATTERN_TB_NOBOOT="tb_noboot"
TB_PATTERN_TB_OVERLAY="tb_overlay"
TB_PATTERN_TB_RESTORE="tb_restore"
TB_PATTERN_TB_ROOTFS_RO="tb_rootfs_ro"

#---PRINT CONSTANTS
TB_MENU_WO_NOCOLOR="(${TB_FG_GREY_246}Menu)"
TB_MENU="(${TB_FG_GREY_246}Menu)${TB_NOCOLOR}"

TB_PRINT_ERROR="***:${TB_FG_RED_9}ERROR${TB_NOCOLOR}"
TB_PRINT_WHAT="---:${TB_FG_MAIN_ORANGE_215}WHAT${TB_NOCOLOR}"
TB_PRINT_WHERE="---:${TB_FG_MAIN_ORANGE_215}WHERE${TB_NOCOLOR}"
TB_PRINT_AT="---:${TB_FG_MAIN_ORANGE_215}AT${TB_NOCOLOR}"

TB_PRINT_MODE_ISPBOOOTBIN_BOOTSEQ_SDUSB0USB1="${TB_FG_GREEN_158}SD${TB_FG_GREY_246}>${TB_FG_GREEN_158}USB0${TB_FG_GREY_246}>${TB_FG_GREEN_158}USB1${TB_NOCOLOR}"
TB_PRINT_MODE_ISPBOOOTBIN_BOOTSEQ_SDUSB1USB0="${TB_FG_GREEN_158}SD${TB_FG_GREY_246}>${TB_FG_GREEN_158}USB1${TB_FG_GREY_246}>${TB_FG_GREEN_158}USB0${TB_NOCOLOR}"
TB_PRINT_MODE_ISPBOOOTBIN_BOOTSEQ_USB0SDUSB1="${TB_FG_GREEN_158}USB0${TB_FG_GREY_246}>${TB_FG_GREEN_158}SD${TB_FG_GREY_246}>${TB_FG_GREEN_158}USB1${TB_NOCOLOR}"
TB_PRINT_MODE_ISPBOOOTBIN_BOOTSEQ_USB0USB1SD="${TB_FG_GREEN_158}USB0${TB_FG_GREY_246}>${TB_FG_GREEN_158}USB1${TB_FG_GREY_246}>${TB_FG_GREEN_158}SD${TB_NOCOLOR}"
TB_PRINT_MODE_ISPBOOOTBIN_BOOTSEQ_USB1SDUSB0="${TB_FG_GREEN_158}USB1${TB_FG_GREY_246}>${TB_FG_GREEN_158}SD${TB_FG_GREY_246}>${TB_FG_GREEN_158}USB0${TB_NOCOLOR}"
TB_PRINT_MODE_ISPBOOOTBIN_BOOTSEQ_USB1USB0SD="${TB_FG_GREEN_158}USB1${TB_FG_GREY_246}>${TB_FG_GREEN_158}USB0${TB_FG_GREY_246}>${TB_FG_GREEN_158}SD${TB_NOCOLOR}"

TB_PRINT_OPTIONS_SEMICOLON_B="${TB_FG_YELLOW_33};${TB_NOCOLOR}b"
TB_PRINT_OPTIONS_SEMICOLON_C="${TB_FG_YELLOW_33};${TB_NOCOLOR}c"
TB_PRINT_OPTIONS_SEMICOLON_H="${TB_FG_YELLOW_33};${TB_NOCOLOR}h"
TB_PRINT_OPTIONS_SEMICOLON_M="${TB_FG_YELLOW_33};${TB_NOCOLOR}m"
TB_PRINT_OPTIONS_SEMICOLON_Q="${TB_FG_YELLOW_33};${TB_NOCOLOR}q"

TB_PRINT_UPDATE="---:${TB_FG_BLUE_45}UPDATE${TB_NOCOLOR}"

#---REGEX CONSTANTS
TB_BOOTINTO_MYCHOICE_REGEX="[1234mq]"
TB_ISPBOOOTBIN_BOOTSEQ_MYCHOICE_REGEX="[123456mq]"
TB_MAINMENU_MYCHOICE_REGEX="[123rq]"
TB_RQ_REGEX="[rq]"
TB_YN_REGEX="[yn]"

#---REMARK CONSTANTS
TB_REMARKS="${TB_FG_BLUE_45}Remarks:${TB_NOCOLOR}"
TB_REMARK_A_REBOOT_IS_REQUIRED_FOR_THE_CHANGE_TO_TAKE_EFFECT="${TB_FG_BLUE_33}A reboot is required for the change to take effect${TB_NOCOLOR}"
TB_REMARK_INSUFFICIENT_DISKSPACE="${TB_FG_RED_9}*${TB_NOCOLOR}: ${TB_FG_RED_9}insufficient disk space${TB_NOCOLOR}"

#---SED CONSTANTS
TB_SED_PATTERN_LBRACKET_D_RBRACKET="\\[d\\]"
TB_SED_SLASH="\\/"

#---SPACE CONSTANTS
TB_EMPTYSTRING=""
TB_ONESPACE=" "
TB_TWOSPACES="${TB_ONESPACE}${TB_ONESPACE}"
TB_THREESPACES="${TB_TWOSPACES}${TB_ONESPACE}"
TB_FOURSPACES="${TB_TWOSPACES}${TB_TWOSPACES}"

#---PATHS
tb_dev_dir="/dev"
tb_media_dir="/media"
tb_overlay_dir="/overlay"
tb_proc_dir="/proc"
tb_rootfs_dir="/"
tb_tb_reserve_dir="/tb_reserve"
tb_tmp_dir="/tmp"

tb_init_backup_lst_fpath=${tb_tb_reserve_dir}/.tb_init_backup.lst
tb_init_bootargs_cfg_fpath=${tb_tb_reserve_dir}/.tb_init_bootargs.cfg
tb_init_bootargs_tmp_fpath=${tb_tb_reserve_dir}/.tb_init_bootargs.tmp
tb_init_bootseq_sdusb0usb1_fpath=${tb_tb_reserve_dir}/.tb_init_bootseq_sdusb0usb1
tb_init_bootseq_sdusb1usb0_fpath=${tb_tb_reserve_dir}/.tb_init_bootseq_sdusb1usb0
tb_init_bootseq_usb0sdusb1_fpath=${tb_tb_reserve_dir}/.tb_init_bootseq_usb0sdusb1
tb_init_bootseq_usb0usb1sd_fpath=${tb_tb_reserve_dir}/.tb_init_bootseq_usb0usb1sd
tb_init_bootseq_usb1sdusb0_fpath=${tb_tb_reserve_dir}/.tb_init_bootseq_usb1sdusb0
tb_init_bootseq_usb1usb0sd_fpath=${tb_tb_reserve_dir}/.tb_init_bootseq_usb1usb0sd
tb_overlay_current_cfg_fpath=${tb_tb_reserve_dir}/.tb_overlay_current.cfg
tb_proc_cmdline_fpath=${tb_proc_dir}/cmdline



#---VARIABLES
tb_bootoptions_get="${TB_EMPTYSTRING}"
tb_bootoptions_mychoice="${TB_EMPTYSTRING}"
tb_bootoptions_remarks="${TB_EMPTYSTRING}"
tb_bootoptions_set="${TB_EMPTYSTRING}"
tb_bootoptions_set_printable="${TB_EMPTYSTRING}"
tb_bootoptions_status="${TB_EMPTYSTRING}"
tb_confirm_keyinput="${TB_EMPTYSTRING}"
tb_data_path_set="${TB_EMPTYSTRING}"
tb_data_dstfile_set="${TB_EMPTYSTRING}"
tb_data_dstpath_set="${TB_EMPTYSTRING}"
tb_data_srcpath_set="${TB_EMPTYSTRING}"
tb_disksizes_compare_result="${TB_EMPTYSTRING}"
tb_editmode_set="${TB_EMPTYSTRING}"
tb_editmode_set_printable="${TB_EMPTYSTRING}"
tb_init_bootargs_cfg_tb_rootfs_ro_get="${TB_EMPTYSTRING}"
tb_ispboootbin_bootseq_set="${TB_EMPTYSTRING}"
tb_ispboootbin_bootseq_mychoice="${TB_EMPTYSTRING}"
tb_ispboootbin_bootseq_printable="${TB_EMPTYSTRING}"
# tb_keyinput_bck="${TB_EMPTYSTRING}"
tb_keyinput_tot="${TB_EMPTYSTRING}"
tb_mainmenu_mychoice="${TB_EMPTYSTRING}"
tb_overlaymode_set="${TB_EMPTYSTRING}"
tb_overlaymode_set_printable="${TB_EMPTYSTRING}"
tb_overlaymode_tag="${TB_EMPTYSTRING}"

tb_proc_cmdline_tb_overlay_get="${TB_EMPTYSTRING}"
tb_proc_cmdline_tb_rootfs_ro_get="${TB_EMPTYSTRING}"
tb_remark="${TB_EMPTYSTRING}"

tb_exitcode=0

tb_keyinput_tot_len=0
tb_keyinput_tot_len1=0
tb_keyinput_tot_len2=0

tb_listpage_start=0
tb_numoflines_correction=0

tb_path_list_arr=()
tb_path_list_arrlen=0

flag_backupmode_or_restoremode_exitloop=false
flag_backupmode_or_restoremode_child_exitloop=false
flag_bootoptions_exitloop=false
flag_dircontent_handler_exitloop=false
flag_diskspace_is_insufficient=false
flag_file_can_be_removed=false
flag_go_back_onestep=false



#---SPECIAL FUNCTIONS
function keyboard_input_disable__func() {
    stty -echo
}
function keyboard_input_enable__func() {
    stty echo
}

function cursor_hide__func() {
    printf '\e[?25l'
}
function cursor_show__func() {
    printf '\e[?25h'
}

function cursor_position__func() {
    #Disable keyboard
    keyboard_input_disable__func

    #Backup current 'stty' state
    oldstty=$(stty -g)

    #Initialize variables
    local pos="${TB_EMPTYSTRING}"

    stty raw -echo min 0
    echo -en "\033[6n" > /dev/tty
    IFS=';' read -r -d R -a pos
    
    #Set 'stty' back to the old state
    stty $oldstty

    #Change from one-based to zero-based.
    #This way'tput' can make use of these values.
    local row=$((${pos[0]:2} - 1))    # strip off the esc-[
    local col=$((${pos[1]} - 1))

    #Output
    echo "${col};${row}"

    #Enable keyboard
    keyboard_input_enable__func
}

function terminal_refresh_disable__func() {
    stty -ixon
}
function terminal_refresh_enable__func() {
    stty ixon
}

function stty_sane__func() {
    stty sane
}



#---FUNCTIONS
function apply_thousand_comma_separator__func() {
    #Input args
    local num__input=${1}

    #Reverse 'num_input'
    local num_rev=$(echo ${num__input} | rev)

    #Get length of 'num_rev'
    local num_rev_len=${#num_rev}

    #Initialize variables
    local num_rev_commaseparated="${TB_EMPTYSTRING}"
    local ctr=0

    #Implement the thousand comma-separator
    for ((i=0; i<${num_rev_len}; i++))
    do
        #Get character 'char' for index 'i'
        char=${num_rev:i:1}

        #Insert comma (,) awhen counter 'ctr=3'
        if [[ ${ctr} -eq 3 ]]; then
            #Append comma (,) to 'num_rev_commaseparated'
            num_rev_commaseparated+="${TB_COMMA}"

            #Reset counter
            ctr=0
        fi

        #Append character 'char' to 'num_rev_commaseparated'
        num_rev_commaseparated+="${char}"

        ((ctr++))
    done

    #Reverse back 'num_rev'
    ret=$(echo ${num_rev_commaseparated} | rev)

    #Output
    echo "${ret}"
}

function backspace__func() {
    #Input args
    local string__input=${1}

    #CHeck if 'string__input' is an EMPTYSTRING
    if [[ -z ${string__input} ]]; then
        return
    fi

    #Constants
    local OFFSET=0

    #Lengths
    local str_input_len=${#string__input}
    local str_output_len=$((str_input_len-1))

    #Get result
    local str_output=${string__input:${OFFSET}:${str_output_len}}

    #Output
    echo "${str_output}"
}

function compact_string__func() {
    #Input args
    local string__input=${1}
    local string_len_max__input=${2}
    local basename_len_min__input=${3}

    #Define constants
	local PHASE_GET_STRING_LEN=10
	local PHASE_GET_NUMOF_SLASH=20
	local PHASE_GET_FIRSTDIR_AND_BASENAME=30
    local PHASE_GET_DIRNAME_COMPACT=40
    local PHASE_GET_BASENAME_COMPACT=50
	local PHASE_GET_OUTPUT_VALUE=60
	local PHASE_EXIT=100

    #Define variables
    local phase="${TB_EMPTYSTRING}"
    local ret="${TB_EMPTYSTRING}"
    local string_basename="${TB_EMPTYSTRING}"
    local string_basename_compact="${TB_EMPTYSTRING}"
    local string_basename_compact_left="${TB_EMPTYSTRING}"
    local string_basename_compact_right="${TB_EMPTYSTRING}"
    local string_compact_left="${TB_EMPTYSTRING}"
    local string_compact_right="${TB_EMPTYSTRING}"
    local string_firstdir="${TB_EMPTYSTRING}"
    local string_dirname_compact="${TB_EMPTYSTRING}"

    local ndiff=0
    local ndiff_half=0
    local numof_slash=0
    local string_compact_left_index_end=0
    local string_compact_right_index_start=0
    local string_basename_compact_avail_len=0
    local string_basename_compact_avail_len_half=0
    local string_basename_compact_left_index_end=0
    local string_basename_compact_right_index_start=0
    local slash_ctr=2
    local string_basename_len=0
    local string_dirname_compact_len=0
    local string_len=0
    local string_len_half=0

    local flag_insert_dotdot_isenabled=false

    #Initialize variables
    phase="${PHASE_GET_STRING_LEN}"
    ret="${string__input}"

    while [[ 1 ]]
    do
        case "${phase}" in
            "${PHASE_GET_STRING_LEN}")
                #Get length of 'string__input'
                string_len=${#string__input}

                if [[ ${string_len} -gt ${string_len_max__input} ]]; then #string_len > string_len_max__input
                    phase="${PHASE_GET_NUMOF_SLASH}"
                else
                    phase="${PHASE_EXIT}"
                fi
                ;;
            "${PHASE_GET_NUMOF_SLASH}")
                #Reset flag
                flag_insert_dotdot_isenabled=false

                #Count the number of slashes
                numof_slash=$(count_numof_occur_of_char_in_string__func "${string__input}" "${TB_SLASH}")

                if [[ ${numof_slash} -le 1 ]]; then #numof_slash <= 1
                    phase="${PHASE_COMPACT_STRING}"
                else
                    phase="${PHASE_GET_FIRSTDIR_AND_BASENAME}"
                fi
                ;;
            "${PHASE_COMPACT_STRING}")
                #Get the difference between 'string_len' and 'string_len_max__input'
                ndiff=$(( string_len - string_len_max__input ))
                #Divide 'ndiff' by 2
                ndiff_half=$(( ndiff / 2 ))
                #Divide 'string_len_half' by 2
                string_len_half=$(( string_len / 2 ))
                
                #Calculate when the left-string ends and when the right-string starts
                string_compact_left_index_end=$(( string_len_half - ndiff_half - 1 ))
                string_compact_right_index_start=$(( string_len_half + ndiff_half + 1 ))

                #Get the left-part of the compact string
                string_compact_left=${string__input:0:string_compact_left_index_end}
                #Get the right-part of the compact string
                string_compact_right=${string__input:string_compact_right_index_start:string_len}

                #Set flag to 'true'
                flag_insert_dotdot_isenabled=true

                phase="${PHASE_GET_OUTPUT_VALUE}"
                ;;
            "${PHASE_GET_FIRSTDIR_AND_BASENAME}")
                #Get the dirname of 'string__input'
                string_firstdir=$(echo "${string__input}" | cut -d"/" -f-2)
                #Get the basename of 'string__input'
                string_basename=$(basename "${string__input}")
                #Get the length of 'string_basename'
                string_basename_len=${#string_basename}

                phase="${PHASE_GET_DIRNAME_COMPACT}"
                ;;
            "${PHASE_GET_DIRNAME_COMPACT}")
                #In case there are sub-directories:
                #1. convert each sub-directory to slash-dot-dot (/..)
                #Remark:
                #   The number of slash-dot-dot (/..) to be added,
                #       depends on 'numof_slash' value.
                string_dirname_compact="${string_firstdir}"
                while [[ ${slash_ctr} -lt ${numof_slash} ]]
                do
                    #Append '/..'
                    string_dirname_compact+="${TB_SLASH}${TB_DOTDOT}"

                    #Increment counter
                    ((slash_ctr++))
                done
            
                #Append a slash (/)
                #Note: this is necessary for the 'ndiff' calculation (later on).
                string_dirname_compact+="/"

                #Update 'string_compact_left'
                string_compact_left="${string_dirname_compact}"

                phase="${PHASE_GET_BASENAME_COMPACT}"
                ;;
            "${PHASE_GET_BASENAME_COMPACT}")
                #Get the length of 'string_firstdir'
                string_dirname_compact_len=${#string_dirname_compact}
                #Calculate the available length which is left to use for generating 'string_basename_compact'
                string_basename_compact_avail_len=$(( string_len_max__input - string_dirname_compact_len ))
                #Divide 'string_basename_compact_avail_len' by 2
                string_basename_compact_avail_len_half=$(( string_basename_compact_avail_len / 2 ))                

                #Initialize variables
                string_basename_compact="${string_basename}"

                #Check if there is sufficient available length left
                if [[ ${string_basename_compact_avail_len} -ge ${basename_len_min__input} ]]; then  #is sufficient
                    #Condition #2: check if the length of 'string_basename' is greater than 'string_basename_compact_avail_len'
                    if [[ ${string_basename_len} -gt ${string_basename_compact_avail_len} ]]; then  #is greater
                        #Calculate when the left-string ends (e.g. string_basename_compact_left_index_end)
                        #   and when the right-string starts (e.g. string_basename_compact_right_index_start)
                        string_basename_compact_left_index_end=$(( string_basename_compact_avail_len_half - 1 ))
                        string_basename_compact_right_index_start=$(( string_basename_len - string_basename_compact_avail_len_half + 1 ))

                        string_basename_compact_left=${string_basename:0:string_basename_compact_left_index_end}
                        string_basename_compact_right=${string_basename:string_basename_compact_right_index_start:string_basename_len}
                        string_basename_compact="${string_basename_compact_left}${TB_DOTDOT}${string_basename_compact_right}"

                        #Update 'string_compact_right'
                        string_compact_right="${string_basename_compact}"
                    fi  #end of: if [[ ${string_basename_len} -gt ${string_basename_compact_avail_len} ]]

                    phase="${PHASE_GET_OUTPUT_VALUE}"
                else    #is NOT sufficient
                    #Check if 'string_firstdir' is a '/..'
                    if [[ "${string_firstdir}" != "${TB_SLASH}${TB_DOTDOT}" ]]; then
                        #Set 'string_firstdir = /..'
                        string_firstdir="${TB_SLASH}${TB_DOTDOT}"

                        #Reset variables
                        slash_ctr=2

                        phase="${PHASE_GET_DIRNAME_COMPACT}"
                    else
                        phase="${PHASE_COMPACT_STRING}"
                    fi
                fi  #end of: if [[ ${string_basename_compact_avail_len} -ge ${basename_len_min__input} ]]
                ;;
            "${PHASE_GET_OUTPUT_VALUE}")
                #Get the output value
                ret="${string_compact_left}"
                if [[ "${flag_insert_dotdot_isenabled}" == true ]]; then
                    ret+="${TB_DOTDOT}"
                fi
                ret+="${string_compact_right}"

                phase="${PHASE_EXIT}"
                ;;
            "${PHASE_EXIT}")
                break
                ;;
        esac
    done

    #Output
    echo $ret
}

function confirmation__func() {
    #Input args
    local readdialogmsg__input=${1}
    local regex__input=${2}
    local printmsg__input=${3}

    #Define variables
    local keyinput="${TB_OPTIONS_N}"
    local printmsg="${TB_EMPTYSTRING}"

    #Initialize global variablers
    tb_confirm_keyinput="${TB_EMPTYSTRING}"

    #Move-down two lines
    movedown_and_clean__func "${TB_NUMOFLINES_2}"

    #Print message
    echo -e "${printmsg__input}"

    #Move-down one line
    movedown_and_clean__func "${TB_NUMOFLINES_1}"

    #Show read-dialog
    while [[ 1 ]]
    do
        #Select an option
        read -N1 -r -p "${readdialogmsg__input}" tb_confirm_keyinput

        #Only continue if a valid option is selected
        if [[ ! -z ${tb_confirm_keyinput} ]]; then
            if [[ ${tb_confirm_keyinput} =~ ${regex__input} ]]; then
                movedown_and_clean__func "${TB_NUMOFLINES_1}"

                break
            else
                if [[ ${tb_confirm_keyinput} == ${TB_ENTER} ]]; then
                    moveup_and_clean__func "${TB_NUMOFLINES_1}"                    
                else
                    moveup_and_clean__func "${TB_NUMOFLINES_0}"
                fi
            fi
        else
            moveup_and_clean__func "${TB_NUMOFLINES_0}"
        fi
    done
}

function count_numof_occur_of_char_in_string__func() {
    #Input args
    local string__input=${1}
    local char__input=${2}

    #Define variables
    local ret=0

    #Count the number of occurrences
    ret=$(echo "${string__input}" | grep -o "${char__input}" | wc -l)

    #Output
    echo "${ret}"
}

function devpart_size_kb__func() {
    #Input args
    local path__input=${1}

    #Get source size in Bytes
    srcsize_B=$(blockdev --getsize64 "${path__input}" 2>/dev/null); exitcode=$?

    #Convert from Bytes to KBytes
    if [[ ${exitcode} -eq 0 ]]; then    #no error
        #Convert to Kilobytes
        ret=$((srcsize_B / 1024))
    else    #error
        ret=-1
    fi

    #Output
    echo "${ret}"
}
function dir_freesize_kb__func() {
    #Input args
    local path__input=${1}

    #Get destination size in KB
    ret=$(df --output='avail' -k "${path__input}" | tail -n1 | sed 's/^ *//g' | sed 's/* $//g'); exitcode=$?

    if [[ ${exitcode} -ne 0 ]]; then    #error
        ret=-1
    fi

    #Output
    echo "${ret}"
}
function file_size_kb__func() {
    #Input args
    local targetfpath__input=${1}

    #Get source size in KB
    local filesize_B=$(ls -l "${targetfpath__input}" | awk '{print $5}'); exitcode=$?

    if [[ ${exitcode} -eq 0 ]]; then    #succesful
        #Convert to Kilobytes
        ret=$((filesize_B / 1024))
    else
        ret=-1
    fi

    #Output
    echo "${ret}"
}

function diskspaces_compare__func() {
    #%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    # This function passes the result to 
    # the global variable 'tb_disksizes_compare_result'.
    #%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    #Input args
    local srcpath__input=${1}
    local dstpath__input=${2}
    local copytype__input=${3}

    #Define constants
    local PHASE_BACKUP_SRCSIZE=10
    local PHASE_BACKUP_DSTSIZE=11
    local PHASE_BACKUP_COMPARE_SIZES=12
    local PHASE_BACKUP_EXIT=13
    local PHASE_RESTORE_SRCSIZE=20
    local PHASE_RESTORE_DSTSIZE=21
    local PHASE_RESTORE_COMPARE_SIZES=22
    local PHASE_RESTORE_EXIT=23

    #Define variables
    local phase="${TB_EMPTYSTRING}"
    local printmsg="${TB_EMPTYSTRING}"
    local dstsize_KB_printable="${TB_EMPTYSTRING}"
    local srcsize_KB_printable="${TB_EMPTYSTRING}"
    local exitcode=0
    local dstsize_B=0
    local dstsize_KB=0
    local srcsize_B=0
    local srcsize_KB=0

    #Initialize variables
    tb_disksizes_compare_result="${TB_DISKSIZE_COMPARE_RESULT_INSUFFICIENT}"
    
    case "${copytype__input}" in
        "${TB_TYPE_BACKUP}")
            #Set start phase
            phase="${PHASE_BACKUP_SRCSIZE}"

            while [[ 1 ]]
            do
                case "${phase}" in
                    "${PHASE_BACKUP_SRCSIZE}")
                        #Get source size in Bytes
                        srcsize_KB=$(devpart_size_kb__func "${srcpath__input}")

                        if [[ ${srcsize_B} -ne -1 ]]; then    #succesful
                            #Goto next-phase
                            phase="${PHASE_BACKUP_DSTSIZE}"
                        else    #error
                            #Move down and clean one line
                            movedown_and_clean__func "${TB_NUMOFLINES_1}"

                            #Print error-message
                            printmsg="${TB_PRINT_ERROR}: '${srcpath__input}' is *NOT* a partition\n"
                            printmsg+="${TB_PRINT_ERROR}: SOURCE *must* be an existing partition (e.g. /dev/mmcblk0)"
                            echo -e "${printmsg}"

                            #Goto next-phase
                            phase="${PHASE_BACKUP_EXIT}"
                        fi
                        ;;
                    "${PHASE_BACKUP_DSTSIZE}")
                        dstsize_KB=$(dir_freesize_kb__func "${dstpath__input}")

                        if [[ ${dstsize_KB} -ne -1 ]]; then    #succesful
                            #Goto next-phase
                            phase="${PHASE_BACKUP_COMPARE_SIZES}"
                        else
                            #Move down and clean one line
                            movedown_and_clean__func "${TB_NUMOFLINES_1}"

                            #Print error-message
                            printmsg="${TB_PRINT_ERROR}: '${dstpath__input}' does *NOT* exist\n"
                            printmsg+="${TB_PRINT_ERROR}: please choose an existing DESTINATION location for the backup-file"
                            echo -e "${printmsg}"

                            #Set exitcode
                            exitcode=99

                            #Goto next-phase
                            phase="${PHASE_BACKUP_EXIT}"
                        fi
                        ;;
                    "${PHASE_BACKUP_COMPARE_SIZES}")
                        #Compare 'dstsize_KB' with 'srcsize_KB'
                        #Note: dstsize_KB MUST be greater than 'srcsize_KB'
                        if [[ ${dstsize_KB} -gt ${srcsize_KB} ]]; then
                            #Set exitcode
                            exitcode=0
                        else
                            #Move down and clean one line
                            movedown_and_clean__func "${TB_NUMOFLINES_1}"

                            #Implement Thousand Comma Separator
                            dstsize_KB_printable=$(apply_thousand_comma_separator__func "${dstsize_KB}")
                            srcsize_KB_printable=$(apply_thousand_comma_separator__func "${srcsize_KB}")

                            #Print
                            printmsg="Src: ${srcpath__input}: ${srcsize_KB_printable}K\n"
                            printmsg+="Dst: ${dstpath__input}: ${dstsize_KB_printable}K\n"
                            printmsg+="${TB_PRINT_ERROR}: *insufficient* diskspace (${srcsize_KB_printable}K > ${dstsize_KB_printable}K)\n"
                            printmsg+="${TB_PRINT_ERROR}: free up diskspace or choose another destination"
                            echo -e "${printmsg}"

                            #Set exitcode
                            exitcode=99
                        fi

                        #Goto next-phase
                        phase="${PHASE_BACKUP_EXIT}"
                        ;;
                    "${PHASE_BACKUP_EXIT}")
                        if [[ ${exitcode} -eq 0 ]]; then    #error occurred
                            tb_disksizes_compare_result="${TB_DISKSIZE_COMPARE_RESULT_SUFFICIENT}"
                        else
                            tb_disksizes_compare_result="${TB_DISKSIZE_COMPARE_RESULT_INSUFFICIENT}"
                        fi

                        break
                        ;;
                esac
            done
            ;;
        "${TB_TYPE_RESTORE}")
            #Set start phase
            phase="${PHASE_RESTORE_SRCSIZE}"

            while [[ 1 ]]
            do
                case "${phase}" in
                    "${PHASE_RESTORE_SRCSIZE}")
                        srcsize_KB=$(file_size_kb__func "${srcpath__input}")

                        if [[ ${srcsize_KB} -ne -1 ]]; then    #succesful
                            #Goto next-phase
                            phase="${PHASE_RESTORE_DSTSIZE}"
                        else
                            #Print error-message
                            printmsg="${TB_PRINT_ERROR}: ${srcpath__input} is *NOT* a backup-file\n"
                            printmsg+="${TB_PRINT_ERROR}: SOURCE *must* be an existing backup-file\n"
                            echo -e "${printmsg}"

                            #Set exitcode
                            exitcode=99

                            #Goto next-phase
                            phase="${PHASE_RESTORE_EXIT}"
                        fi
                        ;;
                    "${PHASE_RESTORE_DSTSIZE}")
                        #Get source size in Bytes
                        dstsize_KB=$(devpart_size_kb__func "${dstpath__input}")

                        if [[ ${dstsize_KB} -ne -1 ]]; then    #succesful
                            #Goto next-phase
                            phase="${PHASE_RESTORE_COMPARE_SIZES}"
                        else    #error
                            #Print error-message
                            printmsg="${TB_PRINT_ERROR}: '${dstpath__input}' is *NOT* a partition\n"
                            printmsg+="${TB_PRINT_ERROR}: DESTINATION *must* be an existing partition (e.g. /dev/mmcblk0)\n"
                            echo -e "${printmsg}"

                            #Goto next-phase
                            phase="${PHASE_RESTORE_EXIT}"
                        fi
                        ;;
                    "${PHASE_RESTORE_COMPARE_SIZES}")
                        #Compare 'dstsize_KB' with 'srcsize_KB'
                        #Note: dstsize_KB MUST be greater than 'srcsize_KB'
                        if [[ ${dstsize_KB} -lt ${srcsize_KB} ]]; then
                            #Implement Thousand Comma Separator
                            dstsize_KB_printable=$(apply_thousand_comma_separator__func "${dstsize_KB}")
                            srcsize_KB_printable=$(apply_thousand_comma_separator__func "${srcsize_KB}")

                            #Print
                            printmsg="Src: ${srcpath__input}: ${srcsize_KB_printable}K\n"
                            printmsg+="Dst: ${dstpath__input}: ${dstsize_KB_printable}K\n"
                            printmsg+="${TB_PRINT_ERROR}: *insufficient* diskspace (${srcsize_KB_printable}K > ${dstsize_KB_printable}K)\n"
                            printmsg+="${TB_PRINT_ERROR}: free up diskspace or choose another destination\n"
                            echo -e "${printmsg}"

                            #Set exitcode
                            exitcode=99
                        else
                            #Set exitcode
                            exitcode=0
                        fi

                        #Goto next-phase
                        phase="${PHASE_RESTORE_EXIT}"
                        ;;
                    "${PHASE_RESTORE_EXIT}")
                        if [[ ${exitcode} -eq 0 ]]; then    #error occurred
                            tb_disksizes_compare_result="${TB_DISKSIZE_COMPARE_RESULT_SUFFICIENT}"
                        else
                            tb_disksizes_compare_result="${TB_DISKSIZE_COMPARE_RESULT_INSUFFICIENT}"
                        fi

                        break
                        ;;
                esac
            done
            ;;
    esac
}

function duplicate_char__func() {
    #Input args
    local char__input=${1}
    local nchar__input=${2}

    #Duplicate 'char__input'
    local ret=`printf '%*s' "${nchar__input}" | tr ' ' "${char__input}"`

    #Print text including Leading Empty Spaces
    echo -e "${ret}"
}

function exit__func() {
    #Input args
    local exitcode__input=${1}
    local numoflines__input=${2}

    #Show cursor, enable keyboard-input, enable terminal refresh
    cursor_keyboard_termrefresh_enable__sub

    #Move-down cursor
    movedown_and_clean__func "${numoflines__input}"

    #Exit with code
    exit ${exitcode__input}
}

function extract_if_and_of_from_string__func() {
    #Extract 'if' and 'of'
    local if=$(cut -d";" -f1 <<< "${tb_bootoptions_get}")
    local of=$(cut -d";" -f2 <<< "${tb_bootoptions_get}")

    #Compact strings (if necessary)
    local if_compact=$(compact_string__func "${if}" "${TB_TABLEWIDTH}" "${TB_BASENAME_COMPACT_LEN_MIN}")
    local of_compact=$(compact_string__func "${of}" "${TB_TABLEWIDTH}" "${TB_BASENAME_COMPACT_LEN_MIN}")

    #Update variables which are made ready for printing
    tb_bootoptions_remarks="${TB_FOURSPACES}${TB_FG_BLUE_33}if${TB_NOCOLOR}:${TB_FG_BLUE_45}${if_compact}${TB_NOCOLOR}\n"
    tb_bootoptions_remarks+="${TB_FOURSPACES}${TB_FG_BLUE_33}of${TB_NOCOLOR}:${TB_FG_BLUE_45}${of_compact}${TB_NOCOLOR}\n"
}

function extract_overlaymode_info__func() {
    #Get 'tb_overlay' value (if present)
    tb_proc_cmdline_tb_overlay_get="${TB_EMPTYSTRING}"
    if [[ -f "${tb_proc_cmdline_fpath}" ]]; then
        tb_proc_cmdline_tb_overlay_get=$(grep -o "${TB_PATTERN_TB_OVERLAY}.*" "${tb_proc_cmdline_fpath}")
    fi

    #Get 'tb_rootfs_ro' values from 2 files (if present)
    tb_proc_cmdline_tb_rootfs_ro_get="${TB_EMPTYSTRING}"
    if [[ -f "${tb_proc_cmdline_fpath}" ]]; then
        tb_proc_cmdline_tb_rootfs_ro_get=$(grep -o "${TB_PATTERN_TB_ROOTFS_RO}.*" "${tb_proc_cmdline_fpath}")
    fi
    tb_init_bootargs_cfg_tb_rootfs_ro_get="${TB_EMPTYSTRING}"
    if [[ -f "${tb_init_bootargs_cfg_fpath}" ]]; then
        tb_init_bootargs_cfg_tb_rootfs_ro_get=$(grep -o "${TB_PATTERN_TB_ROOTFS_RO}.*" "${tb_init_bootargs_cfg_fpath}")
    fi
    tb_overlay_current_cfg_tb_rootfs_ro_get="${TB_EMPTYSTRING}"
    if [[ -f "${tb_overlay_current_cfg_fpath}" ]]; then
        tb_overlay_current_cfg_tb_rootfs_ro_get=$(grep -o "${TB_PATTERN_TB_ROOTFS_RO}.*" "${tb_overlay_current_cfg_fpath}")
    fi

    #Get tb_overlaymode_set and tb_overlaymode_tag
    extract_overlaymode_info__tb_overlaymode_set_and_tag____func

    #Update printable
    case "${tb_overlaymode_set}" in
        "${TB_MODE_PERSISTENT}")
            tb_overlaymode_set_printable="${TB_FG_GREEN_158}${tb_overlaymode_set}${TB_NOCOLOR}"
            ;;
        "${TB_MODE_NONPERSISTENT}")
            tb_overlaymode_set_printable="${TB_FG_RED_187}${tb_overlaymode_set}${TB_NOCOLOR}"

            ;;
        *)
            tb_overlaymode_set_printable="${TB_MODE_DISABLED}"
            ;;
    esac    

    #Append tag (if applicable)
    if [[ -n "${tb_overlaymode_tag}" ]]; then
        tb_overlaymode_set_printable+=": ${tb_overlaymode_tag}"

        #Remove 'tb_init_bootargs_cfg_fpath' (if applicable)
        extract_overlaymode_info__remove_tb_init_bootargs_cfg____func
    fi
}
function extract_overlaymode_info__tb_overlaymode_set_and_tag____func() {
    #Remark:
    #   This function passes results to global variables:
    #       tb_overlaymode_tag
    #       tb_overlaymode_set

    #Initialize global variables
    tb_overlaymode_tag="${TB_EMPTYSTRING}"
    tb_overlaymode_set="${TB_MODE_DISABLED}"

    #Validate overlay-mode (persistent or non-persistent)
    if [[ -n "${tb_proc_cmdline_tb_overlay_get}" ]]; then
        #Determine the 'tb_overlaymode_set'
        if [[ -z ${tb_init_bootargs_cfg_tb_rootfs_ro_get} ]]; then  #tb_rootfs_ro is NOT set in '/tb_reserve/tb_init_bootargs.cfg'
            if [[ -z ${tb_proc_cmdline_tb_rootfs_ro_get} ]]; then  #tb_rootfs_ro is NOT set in '/proc/cmdline'
                tb_overlaymode_set="${TB_MODE_PERSISTENT}"
            else    #tb_rootfs_ro is set in '/proc/cmdline'
                tb_overlaymode_set="${TB_MODE_NONPERSISTENT}"
            fi
        else    #tb_rootfs_ro is set in '/tb_reserve/tb_init_bootargs.cfg'
            if [[ "${tb_init_bootargs_cfg_tb_rootfs_ro_get}" == "${TB_ROOTFS_RO_IS_NULL}" ]]; then
                tb_overlaymode_set="${TB_MODE_PERSISTENT}"

                if [[ -z "${tb_proc_cmdline_tb_rootfs_ro_get}" ]]; then  #tb_rootfs_ro is NOT set in '/proc/cmdline'
                    flag_file_can_be_removed=true
                else    #tb_rootfs_ro is already set in '/proc/cmdline'
                    flag_file_can_be_removed=false
                fi
            else    #tb_init_bootargs_cfg_tb_rootfs_ro_get = true
                tb_overlaymode_set="${TB_MODE_NONPERSISTENT}"

                if [[ "${tb_proc_cmdline_tb_rootfs_ro_get}" == "${TB_ROOTFS_RO_IS_TRUE}" ]]; then  #tb_rootfs_ro is already set in '/proc/cmdline'
                    flag_file_can_be_removed=true
                else    #tb_rootfs_ro is NOT set in '/proc/cmdline'
                    flag_file_can_be_removed=false
                fi
            fi
        fi

        #Determine the 'tb_overlaymode_tag'
        if [[ "${tb_overlaymode_set}" == "${TB_MODE_PERSISTENT}" ]]; then
            if [[ "${tb_overlay_current_cfg_tb_rootfs_ro_get}" == "${TB_ROOTFS_RO_IS_EMPTYSTRING}" ]]; then
                tb_overlaymode_tag="${TB_LEGEND_SAME}"
            else    #tb_overlay_current_cfg_tb_rootfs_ro_get = TB_ROOTFS_RO_IS_TRUE
                tb_overlaymode_tag="${TB_LEGEND_NEW}"
            fi
        else    #tb_overlaymode_set = TB_MODE_NONPERSISTENT
            if [[ "${tb_overlay_current_cfg_tb_rootfs_ro_get}" == "${TB_ROOTFS_RO_IS_TRUE}" ]]; then
                tb_overlaymode_tag="${TB_LEGEND_SAME}"
            else    #tb_overlay_current_cfg_tb_rootfs_ro_get = TB_ROOTFS_RO_IS_EMPTYSTRING
                tb_overlaymode_tag="${TB_LEGEND_NEW}"
            fi
        fi
    fi
}
function extract_overlaymode_info__remove_tb_init_bootargs_cfg____func() {
    if [[ "${flag_file_can_be_removed}" == true ]]; then
        remove_file__func "${tb_init_bootargs_cfg_fpath}"
    fi
}

function extract_bootoptions_info__func() {
    #Define and initialize variables
    local backup_result="${TB_EMPTYSTRING}"
    local bootoptions_get_raw="${TB_EMPTYSTRING}"
    local bootoptions_get_if="${TB_EMPTYSTRING}"
    local bootoptions_get_of="${TB_EMPTYSTRING}"
    local noboot_result="${TB_EMPTYSTRING}"
    local restore_result="${TB_EMPTYSTRING}"

    #Get 'tb_backup', 'tb_noboot', tb_restore' values (if present)
    if [[ -f "${tb_init_bootargs_tmp_fpath}" ]]; then
        backup_result=$(grep -o "${TB_PATTERN_TB_BACKUP}.*" "${tb_init_bootargs_tmp_fpath}")
        restore_result=$(grep -o "${TB_PATTERN_TB_RESTORE}.*" "${tb_init_bootargs_tmp_fpath}")
        noboot_result=$(grep -o "${TB_PATTERN_TB_NOBOOT}.*" "${tb_init_bootargs_tmp_fpath}")
    fi
   
    #Initialize global variables
    tb_bootoptions_status="${TB_LEGEND_SAME}"
    tb_bootoptions_get="${TB_EMPTYSTRING}"
    tb_bootoptions_set="${TB_MODE_DISABLED}"
    tb_bootoptions_set_printable="${tb_bootoptions_set}"

    #Update variables based on the results (e.g., backup_result, restore_result, noboot_result)
    #Remarks:
    #   sed 's/\s+//g': remove whitespaces
    #   tr -d '\r': remove carriage return
    if [[ -n "${noboot_result}" ]]; then
        tb_bootoptions_get=$(echo "${noboot_result}" | cut -d"=" -f2 | sed 's/\s+//g' | tr -d '\r')

        tb_bootoptions_set="${TB_MODE_CLEAN_BOOT}"

        tb_bootoptions_status="${TB_LEGEND_NEW_PRIORITY}"
    fi
    if [[ -n "${backup_result}" ]]; then
        tb_bootoptions_get=$(echo "${backup_result}" | cut -d"=" -f2 | sed 's/\s+//g' | tr -d '\r')

        tb_bootoptions_set="${TB_MODE_BACKUPMODE}"

        tb_bootoptions_status="${TB_LEGEND_NEW_PRIORITY}"
    fi
    if [[ -n "${restore_result}" ]]; then
        tb_bootoptions_get=$(echo "${restore_result}" | cut -d"=" -f2 | sed 's/\s+//g' | tr -d '\r')

        tb_bootoptions_set="${TB_MODE_RESTOREMODE}"

        tb_bootoptions_status="${TB_LEGEND_NEW_PRIORITY}"
    fi

    #Update printable or remove file
    if [[ "${tb_bootoptions_set}" != "${TB_MODE_DISABLED}" ]]; then
        if [[ ${tb_bootoptions_status} != "${TB_LEGEND_SAME}" ]]; then
            tb_bootoptions_set_printable="${tb_bootoptions_set}: ${TB_LEGEND_NEW_PRIORITY}"
        else
            tb_bootoptions_set_printable="${tb_bootoptions_set}"
        fi
    else    #tb_bootoptions_set = TB_MODE_DISABLED
        #Remove file (if present)
        remove_file__func "${tb_init_bootargs_tmp_fpath}"
    fi
}

function extract_ispboootbin_bootseq_info__func() {
    #Initialize variable
    tb_ispboootbin_bootseq_set="${TB_EMPTYSTRING}"

    #Update 'tb_ispboootbin_bootseq_set' based on the existing file
    while [[ -z "${tb_ispboootbin_bootseq_set}"  ]]
    do
        if [[ -f "${tb_init_bootseq_sdusb0usb1_fpath}" ]]; then
            tb_ispboootbin_bootseq_set="${TB_MODE_ISPBOOOTBIN_BOOTSEQ_SDUSB0USB1}"

            tb_ispboootbin_bootseq_printable="${TB_PRINT_MODE_ISPBOOOTBIN_BOOTSEQ_SDUSB0USB1}"

            break
        fi
        if [[ -f "${tb_init_bootseq_sdusb1usb0_fpath}" ]]; then
            tb_ispboootbin_bootseq_set="${TB_MODE_ISPBOOOTBIN_BOOTSEQ_SDUSB1USB0}"

            tb_ispboootbin_bootseq_printable="${TB_PRINT_MODE_ISPBOOOTBIN_BOOTSEQ_SDUSB1USB0}"

            break
        fi
        if [[ -f "${tb_init_bootseq_usb0sdusb1_fpath}" ]]; then
            tb_ispboootbin_bootseq_set="${TB_MODE_ISPBOOOTBIN_BOOTSEQ_USB0SDUSB1}"

            tb_ispboootbin_bootseq_printable="${TB_PRINT_MODE_ISPBOOOTBIN_BOOTSEQ_USB0SDUSB1}"

            break
        fi
        if [[ -f "${tb_init_bootseq_usb0usb1sd_fpath}" ]]; then
            tb_ispboootbin_bootseq_set="${TB_MODE_ISPBOOOTBIN_BOOTSEQ_USB0USB1SD}"

            tb_ispboootbin_bootseq_printable="${TB_PRINT_MODE_ISPBOOOTBIN_BOOTSEQ_USB0USB1SD}"

            break
        fi
        if [[ -f "${tb_init_bootseq_usb1sdusb0_fpath}" ]]; then
            tb_ispboootbin_bootseq_set="${TB_MODE_ISPBOOOTBIN_BOOTSEQ_USB1SDUSB0}"

            tb_ispboootbin_bootseq_printable="${TB_PRINT_MODE_ISPBOOOTBIN_BOOTSEQ_USB1SDUSB0}"

            break
        fi
        if [[ -f "${tb_init_bootseq_usb1usb0sd_fpath}" ]]; then
            tb_ispboootbin_bootseq_set="${TB_MODE_ISPBOOOTBIN_BOOTSEQ_USB1USB0SD}"

            tb_ispboootbin_bootseq_printable="${TB_PRINT_MODE_ISPBOOOTBIN_BOOTSEQ_USB1USB0SD}"

            break
        fi

        #In case 'tb_ispboootbin_bootseq_set' is still an Empty String
        tb_ispboootbin_bootseq_set="${TB_MODE_ISPBOOOTBIN_BOOTSEQ_SDUSB0USB1}"
    
        #Update 'tb_ispboootbin_bootseq_printable'
        tb_ispboootbin_bootseq_printable="${TB_PRINT_MODE_ISPBOOOTBIN_BOOTSEQ_SDUSB0USB1}"
    done
}

function extract_string_based_on_specified_substring_from_file__func() {
    #Input args
    local pattern__input=${1}
    local delimiter__input=${2}
    local fieldnum__input=${3}
    local targetfpath__input=${4}

    #Define variables
    local ret=0

    #Find match and get line-number
    ret=$(grep -F "${pattern__input}" "${targetfpath__input}" | \
            cut -d"${delimiter__input}" -f"${fieldnum__input}")

    #Output
    echo "${ret}"
}

function filename_generate_unique__func() {
    #Input args
    local fullpath__input=${1}

    #Define variables
    local extension="${TB_EMPTYSTRING}"
    local filename_wo_ext="${TB_EMPTYSTRING}"
    local ret="${TB_EMPTYSTRING}"
    local index=1

    #Generate filename and check if its unique
    while [[ 1 ]]
    do
        #Get filename w/o extension
        filename_wo_ext=$(echo "${fullpath__input}" | rev | cut -d"." -f2- | rev)

        #Get extension
        extension=$(echo "${fullpath__input}" | rev | cut -d"." -f1 | rev)

        #Combine 'filename_wo_ext' and 'extension'
        ret="${filename_wo_ext}_${index}.${extension}"

        #Check if new filename 'ret' exists
        if [[ ! -f "${ret}" ]]; then
            break
        fi

        #Increment index by 1
        ((index++))
    done

    #Output
    echo "${ret}"
}

function functionKey_detection__func() {
    #Define variables
    local ret="${TB_EMPTYSTRING}"

    # Flush "^[" within 0.1 sec timeout.
    read -rsn1 -t 0.1 key2
    
    #Check if 2nd key is the kapital letter 'O'
    case "${key2}" in
        "${TB_FUNC_O}")
            #Check if the 3rd key is any of the following letters
            read -rsn1 -t 0.1 key3
            case "${key3}" in
                "${TB_FUNC_P}")    #F1
                    ret=${TB_FUNC_F1}
                    ;;
                "${TB_FUNC_Q}")    #F2
                    ret=${TB_FUNC_F2}
                    ;;
                "${TB_FUNC_R}")    #F3
                    ret=${TB_FUNC_F3}
                    ;;
                "${TB_FUNC_S}")    #F4
                    ret=${TB_FUNC_F4}
                    ;;
                *)
                    ;;
            esac
            ;;
        "${TB_FUNC_SLB}")
            #Check if the following 2 keys are any of the following 2-digit numbers
            read -rsn2 -t 0.1 key3
            case "${key3}" in
                "${TB_FUNC_15}")    #F5
                    ret=${TB_FUNC_F5}
                    ;;
                "${TB_FUNC_17}")    #F6
                    ret=${TB_FUNC_F6}
                    ;;
                "${TB_FUNC_18}")    #F7
                    ret=${TB_FUNC_F7}
                    ;;
                "${TB_FUNC_19}")    #F8
                    ret=${TB_FUNC_F8}
                    ;;
                "${TB_FUNC_20}")    #F9
                    ret=${TB_FUNC_F9}
                    ;;
                "${TB_FUNC_21}")    #F10
                    ret=${TB_FUNC_F10}
                    ;;
                "${TB_FUNC_24}")    #F12
                    ret=${TB_FUNC_F12}
                    ;;
                *)
                    ;;
            esac
    esac

    #Flush "stdin" with 0.1  sec timeout.
    read -rsn5 -t 0.1

    #Output
    echo "${ret}"
}

function get_stringlen_wo_color__func() {
    #Input args
    local string__input=${1}
    
    #Get string w/o color
    local string_wo_color=$(echo "${string__input}" | sed "s,\x1B\[[0-9;]*m,,g")

    #Update length
    local string_wo_color_len="${#string_wo_color}"

    #Move-back with a specified number of chars
    echo "${string_wo_color_len}"
}

function isNumeric__func() {
    #Input args
    local string__input=${1}

    #Define variables
    local re='^[0-9]+$'

    #Check if 'string__input' is numeric
    if [[ $string__input =~ $re ]] ; then
        echo true
    else
        echo false
    fi
}

function movedown__func() {
    #Input args
    local numoflines__input=${1}

    #Exit right away if 'numoflines__input = 0'
    if [[ ${numoflines__input} -eq 0 ]]; then
        return 0;
    fi

    #Hide cursor
    cursor_hide__func

    tput cud ${numoflines__input}

    #Show cursor
    cursor_show__func
}

function movedown_and_clean__func() {
    #Input args
    local numoflines__input=${1}

    #Hide cursor
    cursor_hide__func

    #Clear lines
    local tcounter=1
    if [[ ${numoflines__input} -ne 0 ]]; then
        while [[ ${tcounter} -le ${numoflines__input} ]]
        do
            #Move-down 1 line and clean
            tput cud1
            tput el1 && tput el

            #Increment tcounter by 1
            ((tcounter++))
        done
    else
        tput el1 && tput el
    fi

    #Show cursor
    cursor_show__func
}

function moveleft_basedon_echomsg__func() {
    #Input args
    local string__input=${1}
    
    #Update length
    local string_wo_color_len=$(get_stringlen_wo_color__func "${string__input}")

    #Move-back with a specified number of chars
    tput cub ${string_wo_color_len}
}
function moveright_basedon_echomsg__func() {
    #Input args
    local string__input=${1}

    #Update length
    local string_wo_color_len=$(get_stringlen_wo_color__func "${string__input}")

    #Move-back with a specified number of chars
    tput cuf ${string_wo_color_len}
}

function moveup__func() {
    #Input args
    local numoflines__input=${1}

    #Exit right away if 'numoflines__input = 0'
    if [[ ${numoflines__input} -eq 0 ]]; then
        return 0;
    fi

    #Hide cursor
    cursor_hide__func

    #Move-up 1 line
    tput cuu ${numoflines__input}

    #Show cursor
    cursor_show__func
}

function moveup_and_clean__func() {
    #Input args
    local numoflines__input=${1}

    #Hide cursor
    cursor_hide__func

    #Clear lines
    local xpos_current=0

    if [[ ${numoflines__input} -ne 0 ]]; then
        local tcounter=1
        while [[ ${tcounter} -le ${numoflines__input} ]]
        do
            #clean current line, Move-up 1 line and clean
            tput el1
            tput cuu1
            tput el

            #Increment tcounter by 1
            ((tcounter++))
        done
    else
        tput el1
    fi

    #Get current x-position of cursor
    xpos_current=${TB_TERMWINDOW_WIDTH}

    #Move to the beginning of line
    tput cub ${xpos_current}

    #Show cursor
    cursor_show__func
}

function print_centered_string__func() {
    #Input args
    local str__input=${1}
    local tablewidth__input=${2}
    local bgcolor__input=${3}

    #Set 'bgcolor__input' to 'TB_NOCOLOR'
    if [[ -z ${bgcolor__input} ]]; then
        bgcolor__input=${TB_NOCOLOR}
    fi

    #Get string 'without visiable' color characters
    local str_wo_colorchars=`echo "${str__input}" | sed "s,\x1B\[[0-9;]*m,,g"`

    #Get string-length
    local str_wo_colorchars_len=${#str_wo_colorchars}

    #Create string containing only empty spaces
    local str_of_emptyspaces=`duplicate_char__func "${TB_ONESPACE}" "${tablewidth__input}"`

    #Calculate the number of spaces to-be-prepended
    local str_startpos=$(( (tablewidth__input - str_wo_colorchars_len)/2 ))


    #Print empty spaces only with background color
    echo -e "${bgcolor__input}${str_of_emptyspaces}${TB_NOCOLOR}"

    #Move-up cursor
    tput cuu1

    #Move cursor to the start position to input string
    tput cuf ${str_startpos}

    #Print string
    echo -e "${bgcolor__input}${str__input}${TB_NOCOLOR}"
}

function print_centered_string_w_leading_trailing_emptylines__func() {
    #Input args
    local menutitle__input=${1}
    local tablewidth__input=${2}
    local bgcolor__input=${3}
    local prepend_numoflines__input=${4}
    local append_numoflines__input=${5}

    #Move-down and clean
    movedown_and_clean__func "${prepend_numoflines__input}"

    #Print title
    print_centered_string__func "${menutitle__input}" "${tablewidth__input}" "${bgcolor__input}"

    #Move-down and clean
    movedown_and_clean__func "${append_numoflines__input}"
}

function print_duplicate_char__func() {
    #Input args
    local char__input=${1}
    local nchar__input=${2}
    local bgcolor__input=${3}

    #Create string containing only empty spaces
    local chars=`duplicate_char__func "${char__input}" "${nchar__input}"`

    #Print string
    echo -e "${bgcolor__input}${chars}${TB_NOCOLOR}"

}

function print_leading_trailing_strings_on_opposite_sides__func() {
    #Input args
    local leadStr__input=${1}
    local trailStr__input=${2}
    local tableWidth__input=${3}

    #Get string 'without visiable' color characters
    local leadStr_input_wo_colorChars=`echo "${leadStr__input}" | sed "s,\x1B\[[0-9;]*m,,g"`
    local trailStr_input_wo_colorChars=`echo "${trailStr__input}" | sed "s,\x1B\[[0-9;]*m,,g"`

    #Get string length
    local leadStr_input_wo_colorChars_len=${#leadStr_input_wo_colorChars}
    local trailStr_input_wo_colorChars_len=${#trailStr_input_wo_colorChars}

    #Calculated the number of spaces to-be-added
    local numOf_spaces=$(( tableWidth__input-(leadStr_input_wo_colorChars_len+trailStr_input_wo_colorChars_len) ))

    #Create a string containing only EMPTY SPACES
    local spaces_leading=`duplicate_char__func "${TB_ONESPACE}" "${numOf_spaces}"`

    #Print text including Leading Empty Spaces
    echo -e "${leadStr__input}${spaces_leading}${trailStr__input}"
}

function print_menuitem__func() {
    #Input args
    local indent__input=${1}
    local optionitem__input=${2}
    local menumsg__input=${3}
    local bracketmsg__input=${4}

    #Update 'printmsg'
    local printmsg="${TB_EMPTYSTRING}"
    if [[ -n "${indent__input}" ]]; then
        printmsg+="${indent__input}"
    fi
    if [[ -n "${optionitem__input}" ]]; then
        printmsg+="${optionitem__input}. "
    fi
    printmsg+="${menumsg__input} "
    if [[ -n ${bracketmsg__input} ]]; then
        # printmsg+="(${TB_FG_GREY_246}${bracketmsg__input}${TB_NOCOLOR})"
        printmsg+="(${bracketmsg__input})"
    fi

    #1. Clean until the end of line, then...
    #2. Clean until beginning of line
    tput el && tput el1

    #Output
    echo -e "${printmsg}"
}

function readdialog_clean_buffer__func() {
    read -t0.01 -p "${TB_EMPTYSTRING}" tmp
}

function remove_file__func() {
    #Input args
    local targetfpath=${1}

    #Remove file
    if [[ -f ${targetfpath} ]]; then
        rm ${targetfpath}
    fi
}

function semicolon_option_validate_and_return_value() {
    #Input args
    local string__input=${1}

	#Define variables
	local all_chars_after_semicolon="${TB_EMPTYSTRING}"
	local all_chars_after_semicolon_len=0
	local semicolon_option="${TB_EMPTYSTRING}"
	local first_char_followed_after_semicolon="${TB_EMPTYSTRING}"
	local string_followed_after_first_char="${TB_EMPTYSTRING}"
	local string_followed_after_first_char_len=0
	local ret="${string__input}"

    #Find the right-most semi-colon and get the string on the right-side of this semicolon
    all_chars_after_semicolon=$(echo "${string__input}" | rev | cut -d";" -f1 | rev)

	if [[ -n "${all_chars_after_semicolon}" ]]; then
		#Get the T character on the right-side of the semicolon
		first_char_followed_after_semicolon=${all_chars_after_semicolon:0:1}

		#Get length of 'all_chars_after_semicolon'
		all_chars_after_semicolon_len=${#all_chars_after_semicolon}

		#Get the string which followed after this FIRST character
		string_followed_after_first_char=${all_chars_after_semicolon:1:all_chars_after_semicolon_len}

		#Get length of 'string_followed_after_first_char'
		string_followed_after_first_char_len=${#string_followed_after_first_char}

		#Combine semicolon (;) with 'first_char_followed_after_semicolon'
		semicolon_option="${TB_SEMICOLON}${first_char_followed_after_semicolon}"

		case "${semicolon_option}" in
			"${TB_OPTIONS_SEMICOLON_C}")
				#Remark: 
				#	if a semicolon-c (;c) was inputted,
				#		then return the substring followed AFTER this semicolon-c.
				ret="${string_followed_after_first_char}"

				#Note: if 'ret' is an empty string, then return the semicolon-c.
				if [[ -z "${ret}" ]]; then
					ret="${semicolon_option}"
				fi
				;;
			*)
				#Remarks:
				#	Only return a semicolon-<any char> (e.g. ;x)
				#		if this semicolon-<any char> is found on the RIGHTMOST side.
				#	For all other cases, return the original string 'string__input' 
				if [[ ${string_followed_after_first_char_len} -eq 0 ]]; then
					ret="${semicolon_option}"
				fi
				;;
		esac
	fi

	#Output
	echo "${ret}"
}

function substring_isfound_in_string__func() {
    #Input args
    local string__input=${1}
    local pattern__input=${2}

    #Define variables
    local result="${TB_EMPTYSTRING}"
    local ret=false

    #Check if 'pattern__input' is found in 'string__input'
    result=$(echo "${string__input}" | grep -o "${pattern__input}")
    if [[ -n "${result}" ]]; then
        ret=true
    fi

    #Output
    echo "${ret}"
}



#---SUBROUTINES
trap tb_ctrl_c__sub SIGINT
tb_ctrl_c__sub() {
    #Remarks:
    #   'tb_numoflines_correction' has been implemented due to 
    #       subroutine 'bootoptions_backupmode_dstfilename_choice_and_action__sub'
    #       where the cursor is moved up with 8 lines.
    local numoflines=$((TB_NUMOFLINES_2 + tb_numoflines_correction))

    #Exit script with exit-code 99
    exit__func "${TB_EXITCODE_99}" "${numoflines}"
}

tibbo_print_title__sub() {
    print_centered_string_w_leading_trailing_emptylines__func "${TB_TITLE_TIBBO}" "${TB_TABLEWIDTH}" "${TB_BG_ORANGE_215}" "${TB_NUMOFLINES_2}" "${TB_NUMOFLINES_0}"
}

cursor_keyboard_termrefresh_disable__sub() {
    cursor_hide__func
    keyboard_input_disable__func
    terminal_refresh_disable__func
}
cursor_keyboard_termrefresh_enable__sub() {
    cursor_show__func
    keyboard_input_enable__func
    terminal_refresh_enable__func
    stty_sane__func
}

dircontent_title_show__sub() {
    #Input args
    local outputtype__input=${1}

    #Hide cursor, disable keyboard-input, disable terminal refresh
    cursor_keyboard_termrefresh_disable__sub

    case "${outputtype__input}" in
        "${TB_BACKUPMODE_DSTDIR}")
            title_msg="${TB_TITLE_BACKUPMODE_CHOOSE_DSTDIR}"
            ;;
        "${TB_BACKUPMODE_DSTFILE}")
            title_msg="${TB_TITLE_BACKUPMODE_INPUT_DSTFILE}"
            ;;
        "${TB_BACKUPMODE_SRCPATH}")
            title_msg="${TB_TITLE_BACKUPMODE_CHOOSE_SRCDIR}"
            ;;
        "${TB_RESTOREMODE_DSTPATH}")
            title_msg="${TB_TITLE_RESTOREMODE_CHOOSE_SRCDIR}"
            ;;
        "${TB_RESTOREMODE_SRCFILE}")
            title_msg="${TB_TITLE_RESTOREMODE_CHOOSE_SRCFILE}"
            ;;
    esac

    #Move-down one line
    movedown_and_clean__func "${TB_NUMOFLINES_1}"

    #Print title
    print_duplicate_char__func "${TB_DASH}" "${TB_TABLEWIDTH}" "${TB_FG_GREY_243}"
    print_leading_trailing_strings_on_opposite_sides__func "${title_msg}" \
            "${TB_EMPTYSTRING}" \
            "${TB_TABLEWIDTH}"
    print_duplicate_char__func "${TB_DASH}" "${TB_TABLEWIDTH}" "${TB_FG_GREY_243}"

	#Show cursor, enable keyboard-input, enable terminal refresh
	cursor_keyboard_termrefresh_enable__sub
}
dircontent_data_extract_and_show__sub() {
    #Input args
    local dir__input=${1}
    local dir_parent__input=${2}
    local pattern__input=${3}
    local listpagestart__input=${4}
    local outputtype__input=${5}
    local flag_back_option_isenabled__input=${6}
    local flag_dir_isfixed__input=${7}
    local flag_type_isdir__input=${8}
    local flag_type_isfile__input=${9}
    local flag_show_menuitem_index_isenabled__input=${10}


    #Hide cursor, disable keyboard-input, disable terminal refresh
    cursor_keyboard_termrefresh_disable__sub


    #Define and initialize variables
    local flag_dircontent_retrieve_isallowed=true
    local title_msg="${TB_EMPTYSTRING}"

    #Check if 'flag_dir_isfixed__input = true' AND 'tb_path_list_arrlen > 0'
    #Note: initially 'tb_path_list_arrlen = 0', therefore 'flag_dircontent_retrieve_isallowed = true' 
    if [[ "${flag_dir_isfixed__input}" == true ]] && [[ ${tb_path_list_arrlen} -gt 0 ]]; then
        flag_dircontent_retrieve_isallowed=false
    fi

    #Get directory contents based on a specified value for 'dir__input'
    #Note: this subroutine passes a value to global variable 'tb_path_list_arr'
    if [[ "${flag_dircontent_retrieve_isallowed}" == true ]]; then
        dircontent_data_extract__sub "${dir__input}" "${pattern__input}" "${flag_type_isdir__input}" "${flag_type_isfile__input}"
    fi

    #Show title
    dircontent_title_show__sub "${outputtype__input}"

    #Show directory content
    dircontent_data_show__sub "${dir__input}" \
            "${dir_parent__input}" \
            "${listpagestart__input}" \
            "${TB_LISTPAGE_LEN}" \
            "${TB_FOURSPACES}" \
            "${TB_TABLEWIDTH}" \
            "${outputtype__input}" \
            "${flag_dir_isfixed__input}" \
            "${flag_show_menuitem_index_isenabled__input}" \
            "${tb_path_list_arr[@]}"

    #Show greyed out remark
    if [[ "${flag_diskspace_is_insufficient}" = true ]]; then
        dircontent_remark_insufficient_diskspace_show__sub
    fi 

    #Show current selected path
    dircontent_selected_path_show__sub "${dir__input}"

    #Show menu-options
    dircontent_menuoptions_show__sub "${flag_show_menuitem_index_isenabled__input}"


	#Show cursor, enable keyboard-input, enable terminal refresh
	cursor_keyboard_termrefresh_enable__sub
}
dircontent_data_extract__sub() {
    #Input args
    local dir__input=${1}
    local pattern__input=${2}
    local flag_type_isdir__input=${3}
    local flag_type_isfile__input=${4}

    #Define variables
    local dir_clean="${TB_EMPTYSTRING}"
    local dir_clean_basename="${TB_EMPTYSTRING}"
    local dirpath_listarr=()
    local dirpath_listarr_item="${TB_EMPTYSTRING}"
    local dirpath_basename="${TB_EMPTYSTRING}"
    local filepath_listarr=()
    local filepath_listarr_item="${TB_EMPTYSTRING}"
    local filepath_basename="${TB_EMPTYSTRING}"
    
    local path_list_arr_index=0

    #Reset variable
    tb_path_list_arr=()
    tb_path_list_arrlen=0

    #Pass "dir__input" content to array 'tb_path_list_arr'
    if [[ -d "${dir__input}" ]]; then
        #Remove the trailing backslash(es) (if present)
        dir_clean=$(echo "${dir__input}" | sed 's/\/*$//g')
        if [[ -z "${dir_clean}" ]]; then
            dir_clean="${TB_SLASH}"
        fi

        #Get the basename of 'dir_clean'
        dir_clean_basename=$(basename "${dir_clean}")
        
        #Get 'dirpath_listarr' based on 'pattern__input' input value
        case "${pattern__input}" in
            "${TB_EMPTYSTRING}")
                #Get list of directory only for specified 'dir__input'
                if [[ "${flag_type_isdir__input}" == true ]]; then
                    readarray -t dirpath_listarr < <(find "${dir_clean}/" -maxdepth 1 -type d | sort --version-sort)
                fi

                #Get list of files only for specified 'dir__input'
                if [[ "${flag_type_isfile__input}" == true ]]; then
                    readarray -t filepath_listarr < <(find "${dir_clean}/" -maxdepth 1 -type f | sort --version-sort)
                fi

                #Add 'dirpath_listarr' to 'tb_path_list_arr' (take only basename)
                for dirpath_listarr_item in "${dirpath_listarr[@]}"
                do
                    dirpath_basename=$(basename "${dirpath_listarr_item}")
                    if [[ "${dir_clean_basename}" != "${dirpath_basename}" ]]; then
                        tb_path_list_arr[path_list_arr_index]="${TB_PATTERN_LBRACKET_D_RBRACKET}${dirpath_basename}"

                        ((path_list_arr_index++))
                    fi
                done

                #Add 'filepath_listarr' to 'tb_path_list_arr' (take only basename)
                for filepath_listarr_item in "${filepath_listarr[@]}"
                do
                    filepath_basename=$(basename "${filepath_listarr_item}")
                    if [[ "-n ${filepath_basename}" ]]; then
                        tb_path_list_arr[path_list_arr_index]="${filepath_basename}"

                        ((path_list_arr_index++))
                    fi
                done
                ;;
            *)
                #Get list of all dev-partitions
                readarray -t filepath_listarr < <(find "${dir_clean}/" -maxdepth 1 | grep "${pattern__input}" | sort --version-sort)

                #Add 'filepath_listarr' to 'tb_path_list_arr' (take only basename)
                for filepath_listarr_item in "${filepath_listarr[@]}"
                do
                    filepath_basename=$(basename "${filepath_listarr_item}")
                    if [[ "-n ${filepath_basename}" ]]; then
                        tb_path_list_arr[path_list_arr_index]="${filepath_basename}"

                        ((path_list_arr_index++))
                    fi
                done
                ;;
        esac
    else    #array does NOT contain data
        tb_path_list_arr=()
    fi

    #Get array-length
    tb_path_list_arrlen=${#tb_path_list_arr[@]}
}
dircontent_data_show__sub() {
    #Input args
    local dir__input=${1}
    local dir_parent__input=${2}
    local listpagestart__input=${3}
    local listpagelen__input=${4}
    local indentstring__input=${5}
    local tablewidth__input=${6}
    local outputtype__input=${7}
    local flag_dir_isfixed__input=${8}
    local flag_show_menuitem_index_isenabled__input=${9}
    shift
    shift
    shift
    shift
    shift
    shift
    shift
    shift
    shift
    local array__input=("$@")



    #Define variables
    local array_item="${TB_EMPTYSTRING}"
    local array_item_compact="${TB_EMPTYSTRING}"
    local array_item_printable="${TB_EMPTYSTRING}"
    local array_item_stripped="${TB_EMPTYSTRING}"
    local array_item_stripped_path="${TB_EMPTYSTRING}"
    local array_item_stripped_path_size_kb=0
    local array_len=0
    local arrow_info="${TB_EMPTYSTRING}"
    local arrow_info_pos=0
    local arrow_info_wo_color="${TB_EMPTYSTRING}"
    local arrow_info_wo_color_len=0
    local arrow_leftpos=0
    local arrow_rightpos=0
    local ctr=1
    local restoremode_dstdir_devpart_basename="${TB_EMPTYSTRING}"
    local restoremode_dstdir_devpart_fpath="${TB_EMPTYSTRING}"
    local restoremode_dstdir_media_basename="${TB_EMPTYSTRING}"
    local restoremode_srcfile_devpart_basename="${TB_EMPTYSTRING}"
    local restoremode_srcfile_devpart_fpath="${TB_EMPTYSTRING}"
    local dir_clean="${TB_EMPTYSTRING}"
    local emptyspaces_line="${TB_EMPTYSTRING}"
    local indentstring_len=0
    local listpage_start=0
    local listpage_end=0
    local menuitem_index=0
    local path_size_kb=0
    local print_arrows="${TB_EMPTYSTRING}"



    #Get 'array__input' length
    array_len=${#array__input[@]}

    #Calculate 'listpage_start' and 'listpage_end'
    listpage_start=${listpagestart__input}
    if [[ ${listpage_start} -gt ${array_len} ]]; then
        listpage_start=${array_len}
    fi

    listpage_end=$((listpagestart__input + listpagelen__input - 1))
    if [[ ${listpage_end} -gt ${array_len} ]]; then
        listpage_end=${array_len}
    fi

    #Initialize variables
    ctr=1
    menuitem_index=0
    flag_diskspace_is_insufficient=false

    #Print [.] and [..]
    #The following 2 conditions have to be met:
    #   flag_dir_isfixed__input = false
    #   dir__input != dir_parent__input
    if [[ "${flag_dir_isfixed__input}" == false ]] && \
            [[ "${dir__input}" != "${dir_parent__input}" ]]; then
        #Print [..]
        echo "${indentstring__input}${TB_OPTIONS_R}. ${TB_FG_BLUE_45}[${TB_NOCOLOR}${TB_DOTDOT}${TB_FG_BLUE_45}]${TB_NOCOLOR}"

        #Print [.]
        echo "${indentstring__input}${TB_OPTIONS_P}. ${TB_FG_BLUE_45}[${TB_NOCOLOR}${TB_DOT}${TB_FG_BLUE_45}]${TB_NOCOLOR}"
    fi

    #Print array-contents
    case "${array_len}" in
        "0")
            echo "${TB_EMPTYSTRING}"
            ;;
        *)
            if [[ "${outputtype__input}" == "${TB_BACKUPMODE_DSTDIR}" ]] || \
                    [[ "${outputtype__input}" == "${TB_RESTOREMODE_DSTPATH}" ]]; then
                if [[ -n "${tb_data_srcpath_set}" ]]; then  #is NOT an Empty String
                    #Get the dev-partition size (try)
                    path_size_kb=$(devpart_size_kb__func "${tb_data_srcpath_set}")
                    if [[ ${path_size_kb} -eq -1 ]]; then    #try failed...this means that 'tb_data_srcpath_set' is a file
                        #Get the file-size
                        path_size_kb=$(file_size_kb__func "${tb_data_srcpath_set}")
                    fi  #end of: if [[ ${exitcode} -ne 0 ]]
                fi  #end of: if[[ -n "${tb_data_srcpath_set}" ]]

                if [[ "${outputtype__input}" == "${TB_RESTOREMODE_DSTPATH}" ]]; then
                    #Extract the fullpath of a folder which belongs to the '/media' directory (e.g. /media/HIEN_FD_F) within 
                    #   file 'tb_init_backup_lst_fpath' which matches the value stored in 'tb_data_srcpath_set'.
                    #Remark:
                    #   The extraction is done here, and not later on within the while-loop,
                    #       because this value needs to be retrieved only once for this session.
                    restoremode_dstdir_devpart_fpath=$(extract_string_based_on_specified_substring_from_file__func \
                            "${tb_data_srcpath_set}" \
                            "${TB_SEMICOLON}" \
                            "${TB_FIELDNUM_1}" \
                            "${tb_init_backup_lst_fpath}")

                    #Get basename of 'restoremode_srcfile_devpart_fpath'
                    restoremode_dstdir_devpart_basename=$(basename "${restoremode_dstdir_devpart_fpath}")
                fi
            fi  #end of: if [[ "${outputtype__input}" == "${TB_BACKUPMODE_DSTDIR}" ]] || [[ "${outputtype__input}" == "${TB_RESTOREMODE_DSTPATH}" ]]

            #Remove the trailing backslash(es) (if present)
            dir_clean=$(echo "${dir__input}" | sed 's/\/*$//g')
            if [[ -z "${dir_clean}" ]]; then
                dir_clean="${TB_SLASH}"
            fi

            #List array content based on the specified 'listpage_start' and 'listpage_end'
            #Remark:
            #   This part will be skippe automatically if 'array__input=()'
            for array_item in "${array__input[@]}"
            do
                if [[ ${ctr} -ge ${listpage_start} ]] && [[ ${ctr} -le ${listpage_end} ]]; then
                    #Check if 'array_item' is a directory
                    if [[ $(substring_isfound_in_string__func "${array_item}" \
                            "${TB_SED_PATTERN_LBRACKET_D_RBRACKET}") == true ]]; then #is a directory
                        #Strip off [d]
                        array_item_stripped=$(echo "${array_item}" | \
                                sed "s/${TB_SED_PATTERN_LBRACKET_D_RBRACKET}//g")

                        #Compact string
                        array_item_compact=$(compact_string__func "${array_item_stripped}" \
                                "${TB_TABLEWIDTH}" \
                                "${TB_BASENAME_COMPACT_LEN_MIN}")

                        #Update 'array_item' by prepending and appending left and right bracket respectively
                        array_item_printable="${TB_FG_BLUE_45}${TB_LSQRBRACK}${TB_NOCOLOR}"
                        array_item_printable+="${array_item_compact}"
                        array_item_printable+="${TB_FG_BLUE_45}${TB_RSQRBRACK}${TB_NOCOLOR}"
                    else    #is a file or dev-partition
                        #For consistency use 'array_item_stripped'
                        #Remark: 
                        #   This variable is needed to be defined here to calculate
                        #       'array_item_stripped_path_size_kb' later on.
                        array_item_stripped="${array_item}"

                        #Compact string
                        array_item_compact=$(compact_string__func "${array_item_stripped}" \
                                "${TB_TABLEWIDTH}" \
                                "${TB_BASENAME_COMPACT_LEN_MIN}")

                        #Initialize variable
                        array_item_printable="${array_item_compact}"

                        #Check if filename, which is the value of 'array_item_stripped', is found in '/tb_reserve/.tb_init_backup.lst'
                        case "${outputtype__input}" in
                            "${TB_RESTOREMODE_SRCFILE}")
                                #Get the fullpath
                                array_item_stripped_path="${dir_clean}/${array_item_stripped}"

                                #Extract the fullpath of dev-partition (e.g. /dev/mmcblk0) within 
                                #   file 'tb_init_backup_lst_fpath' which matches the value stored in 'array_item_stripped'.
                                restoremode_srcfile_devpart_fpath=$(extract_string_based_on_specified_substring_from_file__func "${array_item_stripped_path}" \
                                        "${TB_SEMICOLON}" \
                                        "${TB_FIELDNUM_1}" \
                                        "${tb_init_backup_lst_fpath}")

                                #Get basename of 'restoremode_srcfile_devpart_fpath'
                                restoremode_srcfile_devpart_basename=$(basename "${restoremode_srcfile_devpart_fpath}")

                                #Append 'restoremode_srcfile_devpart_basename' to 'array_item_stripped'
                                if [[ -n "${restoremode_srcfile_devpart_basename}" ]]; then
                                    array_item_printable="${array_item_compact} "
                                    array_item_printable+="${TB_NOCOLOR}("
                                    array_item_printable+="${TB_FG_GREY_246}-> "
                                    array_item_printable+="${TB_FG_GREEN_158}${restoremode_srcfile_devpart_basename}${TB_NOCOLOR}"
                                    array_item_printable+=")"
                                fi  #end of: if [[ -n "${restoremode_srcfile_devpart_basename}" ]]
                                ;;
                            "${TB_RESTOREMODE_DSTPATH}")
                                #Append 'restoremode_dstdir_devpart_basename' to 'array_item_stripped'
                                if [[ "${array_item_stripped}" == "${restoremode_dstdir_devpart_basename}" ]]; then
                                    #Get the basename of 'tb_data_srcpath_set'
                                    restoremode_dstdir_media_basename=$(basename "${tb_data_srcpath_set}")

                                    #Append an arrow-right pointing to 'restoremode_dstdir_media_basename' value
                                    array_item_printable="${array_item_compact} "
                                    array_item_printable+="${TB_NOCOLOR}("
                                    array_item_printable+="${TB_FG_GREY_246}-> "
                                    array_item_printable+="${TB_FG_GREEN_158}${restoremode_dstdir_media_basename}"
                                    array_item_printable+="${TB_FG_GREY_246}${TB_NOCOLOR}"
                                    array_item_printable+=")"
                                fi  #end of: if [[ "${array_item_stripped}" == "${restoremode_dstdir_devpart_basename}" ]]
                                ;;
                        esac
                    fi  #end of: if [[ $(substring_isfound_in_string__func "${array_item_stripped}" "${TB_SED_PATTERN_LBRACKET_D_RBRACKET}") == true ]]

                    #1. Get the disksize (only if outputtype__input = TB_BACKUPMODE_DSTDIR && outputtype__input = TB_RESTOREMODE_DSTPATH)
                    #2. Compare the disksizes (e.g., path_size_kb vs. array_item_stripped_path_size_kb)
                    if [[ "${outputtype__input}" == "${TB_BACKUPMODE_DSTDIR}" ]] || [[ "${outputtype__input}" == "${TB_RESTOREMODE_DSTPATH}" ]]; then
                        #Get the fullpath
                        array_item_stripped_path="${dir_clean}/${array_item_stripped}"

                        #Get the 'array_item_stripped_path' size (try)
                        array_item_stripped_path_size_kb=$(devpart_size_kb__func "${array_item_stripped_path}")

                        if [[ ${array_item_stripped_path_size_kb} -eq -1 ]]; then    #try failed...this means that 'array_item_stripped_path' is directory
                            #Get the file-size
                            array_item_stripped_path_size_kb=$(dir_freesize_kb__func "${array_item_stripped_path}")
                        fi  #end of: if [[ ${array_item_stripped_path_size_kb} -eq -1 ]]

                        #Compare the sizes
                        if [[ ${array_item_stripped_path_size_kb} -lt ${path_size_kb} ]]; then
                            case "${outputtype__input}" in
                                "${TB_BACKUPMODE_DSTDIR}")
                                    #Change the color of the string to GREY
                                    array_item_printable="${TB_FG_GREY_246}"
                                    array_item_printable+="${TB_LSQRBRACK}"
                                    array_item_printable+="${array_item_compact}"
                                    array_item_printable+="${TB_RSQRBRACK}"
                                    ;;
                                "${TB_RESTOREMODE_DSTPATH}")
                                    #Preserve the previously generated 'array_item_printable'
                                    array_item_printable_bck="${array_item_printable}"

                                    #Update 'array_item_printable'
                                    array_item_printable="${TB_FG_GREY_246}"
                                    array_item_printable+="${array_item_printable_bck}"
                                    ;;
                            esac
                            #Append asterisk between round brackets (*)
                            array_item_printable+=" ${TB_NOCOLOR}("
                            array_item_printable+="${TB_FG_RED_9}*${TB_FG_GREY_246}${TB_NOCOLOR}"
                            array_item_printable+=")"

                            #Set flag to 'true'
                            flag_diskspace_is_insufficient=true
                        fi  #end of: if [[ ${array_item_stripped_path_size_kb} -lt ${path_size_kb} ]]
                    fi  #end of: if [[ "${outputtype__input}" == "${TB_BACKUPMODE_DSTDIR}" ]] || [[ "${outputtype__input}" == "${TB_RESTOREMODE_DSTPATH}" ]]

                    #Print menu-item with or without menu-item-index
                    if [[ "${flag_show_menuitem_index_isenabled__input}" == true ]]; then
                        echo "${indentstring__input}${menuitem_index}. ${array_item_printable}"
                    else    #flag_show_menuitem_index_isenabled__input = false
                        echo "${indentstring__input}${array_item_printable}"
                    fi  #end of: if [[ "${flag_show_menuitem_index_isenabled__input}" == true ]]

                    #Increment index by 1
                    ((menuitem_index++))
                elif [[ ${ctr} -gt ${listpage_end} ]]; then #ctr > listpage_end
                    break
                fi  #end of: if [[ ${ctr} -ge ${listpage_start} ]] && [[ ${ctr} -le ${listpage_end} ]]

                ((ctr++))
            done
            ;;
    esac



    #Print next-line
    echo -e "\r"

    #Duplicate emptyspaces which is 'tablewidth__input' in length
    emptyspaces_line=$(duplicate_char__func "${TB_ONESPACE}" "${tablewidth__input}")

    #Print a line with emptyspaces, which is 'tablewidth__input' in length
    echo "${emptyspaces_line}"

    #Show arrow left and right
    indentstring_len=${#indentstring__input}
    arrow_leftpos=${indentstring_len}
    arrow_rightpos=$((tablewidth__input - arrow_leftpos - indentstring_len))

    arrow_info="${TB_FG_MAIN_ORANGE_215}${listpage_start} ${TB_FG_GREY_246}to ${TB_FG_MAIN_ORANGE_215}${listpage_end} "
    arrow_info+="${TB_FG_GREY_246}(${TB_FG_ORANGE_208}${array_len}${TB_FG_GREY_246})${TB_NOCOLOR}"
    arrow_info_wo_color=$(echo "${arrow_info}" | sed "s,\x1B\[[0-9;]*m,,g")
    arrow_info_wo_color_len=${#arrow_info_wo_color}
    arrow_info_pos=$(( (tablewidth__input - arrow_info_wo_color_len) / 2 ))

    #Print left arrow (<) only if 'listpage_start > 1'
    if [[ ${listpage_start} -gt 1 ]]; then
        #Move-down two line and move-right with 'arrow_leftpos' characters
        tput cuu 1 && tput cuf ${arrow_leftpos}

        #Print left arrow
        echo "${TB_FG_YELLOW_33}<${TB_NOCOLOR}"
    fi

    #Print right arrow (>) only if 'listpage_end < array_len'
    if [[ ${listpage_end} -lt ${array_len} ]]; then
        #Move-up one line and move-right with 'arrow_rightpos' characters
        tput cuu1 && tput cuf ${arrow_rightpos}

        #Print right arrow
        echo "${TB_FG_YELLOW_33}>${TB_NOCOLOR}"
    fi

    #In case there were no results
    if [[ ${listpage_start} -eq 0 ]] && [[ ${listpage_end} -eq 0 ]]; then
        tput cuu1
    fi

    #Move-up one line
    tput cuu1 && tput cuf ${arrow_info_pos}
    #Print 'arrow_info'
    echo "${arrow_info}"

    #Print next-line
    echo -e "\r"
}
dircontent_remark_insufficient_diskspace_show__sub() {
    print_duplicate_char__func "${TB_DASH}" "${TB_TABLEWIDTH}" "${TB_FG_GREY_243}"
    print_menuitem__func "${TB_FOURSPACES}" \
            "${TB_EMPTYSTRING}" \
            "${TB_REMARK_INSUFFICIENT_DISKSPACE}" \
            "${TB_EMPTYSTRING}"
}
dircontent_selected_path_show__sub() {
    #Input args
    local path_sel__input=${1}

    #Compact 'path_sel__input' (if necessary)
    local path_sel_compact=$(compact_string__func "${path_sel__input}" \
            "${TB_TABLEWIDTH}" \
            "${TB_BASENAME_COMPACT_LEN_MIN}")

    print_duplicate_char__func "${TB_DASH}" "${TB_TABLEWIDTH}" "${TB_FG_GREY_243}"
    print_menuitem__func "${TB_FOURSPACES}" \
            "${TB_EMPTYSTRING}" \
            "${TB_FG_BLUE_45}${path_sel_compact}${TB_NOCOLOR}" \
            "${TB_EMPTYSTRING}"
}
dircontent_menuoptions_show__sub() {
    #Input args
    flag_show_menuitem_index_isenabled__input=${1}


    #Print grey horizontal line
    print_duplicate_char__func "${TB_DASH}" "${TB_TABLEWIDTH}" "${TB_FG_GREY_243}"

    #Print arrow-left (<) and arrow-right (>)
    print_menuitem__func "${TB_FOURSPACES}" \
            "${TB_OPTIONS_LARROW}" \
            "${TB_OPTIONS_PAGE_PREV}" \
            "${TB_EMPTYSTRING}"
    print_menuitem__func "${TB_FOURSPACES}" \
            "${TB_OPTIONS_RARROW}" \
            "${TB_OPTIONS_PAGE_NEXT}" \
            "${TB_EMPTYSTRING}"
    
    #Print function-key F1
    if [[ "${flag_show_menuitem_index_isenabled__input}" == false ]]; then
        print_menuitem__func "${TB_FOURSPACES}" \
                "${TB_FUNC_F1}" \
                "${tb_editmode_set_printable}" \
                "${TB_EMPTYSTRING}"
    fi
    
    #Print other keys (e.g. B, C, H, M, Q)
    if [[ "${tb_editmode_set}" == "${TB_ON}" ]]; then
        #Reprint all other menu-options and make them grey-color
        if [[ "${flag_back_option_isenabled__input}" == true ]]; then
            print_menuitem__func "${TB_FOURSPACES}" \
                    "${TB_FG_GREY_246}${TB_OPTIONS_B}${TB_NOCOLOR}" \
                    "${TB_FG_GREY_246}${TB_OPTIONS_BACK}${TB_NOCOLOR}" \
                    "${TB_EMPTYSTRING}"
        fi
        print_menuitem__func "${TB_FOURSPACES}" \
                "${TB_FG_GREY_246}${TB_OPTIONS_H}${TB_NOCOLOR}" \
                "${TB_FG_GREY_246}${TB_OPTIONS_HOME}${TB_NOCOLOR}" \
                "${TB_EMPTYSTRING}"
        print_menuitem__func "${TB_FOURSPACES}" \
                "${TB_FG_GREY_246}${TB_OPTIONS_M}${TB_NOCOLOR}" \
                "${TB_FG_GREY_246}${TB_OPTIONS_MAIN}${TB_NOCOLOR}" \
                "${TB_EMPTYSTRING}"
        print_menuitem__func "${TB_FOURSPACES}" \
                "${TB_FG_GREY_246}${TB_OPTIONS_Q}${TB_NOCOLOR}" \
                "${TB_FG_GREY_246}${TB_OPTIONS_QUIT_CTRL_C}${TB_NOCOLOR}" \
                "${TB_EMPTYSTRING}"
    else
        #Reprint selected path and menu-options with default color
        if [[ "${flag_back_option_isenabled__input}" == true ]]; then
            print_menuitem__func "${TB_FOURSPACES}" \
                    "${TB_OPTIONS_B}" \
                    "${TB_OPTIONS_BACK}" \
                    "${TB_EMPTYSTRING}"
        fi
        print_menuitem__func "${TB_FOURSPACES}" \
                "${TB_OPTIONS_H}" \
                "${TB_OPTIONS_HOME}" \
                "${TB_EMPTYSTRING}"
        print_menuitem__func "${TB_FOURSPACES}" \
                "${TB_OPTIONS_M}" \
                "${TB_OPTIONS_MAIN}" \
                "${TB_EMPTYSTRING}"
        print_menuitem__func "${TB_FOURSPACES}" \
                "${TB_OPTIONS_Q}" \
                "${TB_OPTIONS_QUIT_CTRL_C}" \
                "${TB_EMPTYSTRING}"
    fi

    #Print grey horizontal line
    print_duplicate_char__func "${TB_DASH}" "${TB_TABLEWIDTH}" "${TB_FG_GREY_243}"
}

dircontent_handler__sub() {
    #Input args
    local dir__input=${1}
    local dir_parent__input=${2}
    local outputtype__input=${3}
    local readdialog_msg1__input=${4}
    local readdialog_msg2__input=${5}
    local flag_back_option_isenabled__input=${6}
    local flag_dir_isfixed__input=${7}
    local flag_show_menuitem_index_isenabled__input=${8}
    local flag_dir_parent_isnot_tobe_used__input=${9}

    #Initialize global variables
    flag_backupmode_or_restoremode_exitloop=false
    flag_backupmode_or_restoremode_child_exitloop=false
    flag_dircontent_handler_exitloop=false
    flag_go_back_onestep=false

    while [[ "${flag_dircontent_handler_exitloop}" == false ]]
    do
        case "${outputtype__input}" in
            "${TB_BACKUPMODE_DSTFILE}")
                dircontent_handler_dstfile_input__sub "${dir__input}" \
                        "${dir_parent__input}" \
                        "${outputtype__input}" \
                        "${readdialog_msg1__input}" \
                        "${readdialog_msg2__input}" \
                        "${flag_back_option_isenabled__input}" \
                        "${flag_dir_isfixed__input}" \
                        "${flag_show_menuitem_index_isenabled__input}"
                ;;
            *)
                dircontent_handler_srcpath_dstpath_select__sub "${dir__input}" \
                        "${dir_parent__input}" \
                        "${outputtype__input}" \
                        "${readdialog_msg1__input}" \
                        "${readdialog_msg2__input}" \
                        "${flag_back_option_isenabled__input}" \
                        "${flag_dir_isfixed__input}" \
                        "${flag_show_menuitem_index_isenabled__input}" \
                        "${flag_dir_parent_isnot_tobe_used__input}"
                ;;
        esac

        #Clean line
        moveup_and_clean__func "${TB_NUMOFCOLUMNS_0}"
    done
}
dircontent_handler_dstfile_input__sub() {
    #Input args
    local dir__input=${1}
    local dir_parent__input=${2}
    local outputtype__input=${3}
    local readdialog_msg1__input=${4}
    local readdialog_msg2__input=${5}
    local flag_back_option_isenabled__input=${6}
    local flag_dir_isfixed__input=${7}
    local flag_show_menuitem_index_isenabled__input=${8}


    #Initalize variables
    local echomsg="${TB_EMPTYSTRING}"
    local echomsg_wo_color="${TB_EMPTYSTRING}"
    local filename_new="${TB_EMPTYSTRING}"
    local fpath="${TB_EMPTYSTRING}"
    local fpath_new="${TB_EMPTYSTRING}"
    local funckey="${TB_EMPTYSTRING}"
    local keyinput="${TB_EMPTYSTRING}"
    local keyinput_backspace_tmp="${TB_EMPTYSTRING}"
    local keyinput_paste_tmp="${TB_EMPTYSTRING}"
    local myanswer="${TB_EMPTYSTRING}"
    local printmsg="${TB_EMPTYSTRING}"
    local readdialog_msg="${TB_EMPTYSTRING}"

    local echomsg_wo_color_len=0
    local listpage_start_bck=0
    local path_list_arr_selindex=0
    local path_list_arr_selindex_max=0

    local flag_print_tb_keyinput_tot_isenabled=false


    #Select the read-dialog based on 'tb_editmode_set'
    case "${tb_editmode_set}" in
        "${TB_OFF}")
            readdialog_msg="${readdialog_msg1__input}"
            ;;
        *)
            readdialog_msg="${readdialog_msg2__input}"
            ;;
    esac

    #Print the read-dialog
    printf "%s" "${readdialog_msg}"

    #Save cursor position (for later usage)
    tput sc

    while [[ 1 ]]
    do
        if [[ ${flag_print_tb_keyinput_tot_isenabled} == false ]]; then
            #Print every 'keyinput'
            printf "%s" "${keyinput}"
        else
            #Restore cursor position (which was saved previously)
            tput rc

            #Clean until the end of line
            tput el

            #Print all the characters which have been keyed in so far
            printf "%s" "${tb_keyinput_tot}"

            #Set flag back to 'false'
            flag_print_tb_keyinput_tot_isenabled=false
        fi

        #Reset variables
        funckey="${TB_EMPTYSTRING}"
        keyinput="${TB_EMPTYSTRING}"

        #Show cursor, enable keyboard-input, enable terminal refresh
        cursor_keyboard_termrefresh_enable__sub

        #Execute read-dialog and wait for input
        read -N1 -rs keyinput

        #Hide cursor, disable keyboard-input, disable terminal refresh
        cursor_keyboard_termrefresh_disable__sub

        case "${keyinput}" in
            "${TB_OPTIONS_LARROW}")
                #Backup variable
                listpage_start_bck=${tb_listpage_start}

                #Decrement variable
                tb_listpage_start=$(( listpage_start_bck - TB_LISTPAGE_LEN ))

                #Final action
                if [[ ${tb_listpage_start} -gt 0 ]]; then
                    #Set flag to true
                    flag_dircontent_handler_exitloop=true

                    #Move down and clean two lines
                    movedown_and_clean__func "${TB_NUMOFLINES_2}"

                    break
                else
                    tb_listpage_start=${listpage_start_bck}
                fi
                ;;
            "${TB_OPTIONS_RARROW}")
                #Backup variable
                listpage_start_bck=${tb_listpage_start}

                #Incrementvariable
                tb_listpage_start=$(( tb_listpage_start + TB_LISTPAGE_LEN ))

                #Final action
                if [[ ${tb_listpage_start} -le ${tb_path_list_arrlen} ]]; then
                    #Set flag to true
                    flag_dircontent_handler_exitloop=true

                    #Move down and clean two lines
                    movedown_and_clean__func "${TB_NUMOFLINES_2}"

                    break
                else
                    tb_listpage_start=${listpage_start_bck}
                fi
                ;;
            "${TB_OPTIONS_B}")
                case "${tb_editmode_set}" in
                    "${TB_ON}")
                        #Append 'keyinput' to 'tb_keyinput_tot'
                        tb_keyinput_tot+="${keyinput}"
                        ;;
                    *)
                        #Move down and clean one line
                        movedown_and_clean__func "${TB_NUMOFLINES_2}"

                        #Set flags to true
                        flag_dircontent_handler_exitloop=true
                        flag_backupmode_or_restoremode_child_exitloop=true
                        flag_go_back_onestep=true

                        break
                        ;;
                esac
                ;;
            "${TB_OPTIONS_H}")
                case "${tb_editmode_set}" in
                    "${TB_ON}")
                        #Append 'keyinput' to 'tb_keyinput_tot'
                        tb_keyinput_tot+="${keyinput}"
                        ;;
                    *)
                        #Move down and clean one line
                        movedown_and_clean__func "${TB_NUMOFLINES_1}"

                        #Set flags to true
                        flag_dircontent_handler_exitloop=true
                        flag_backupmode_or_restoremode_child_exitloop=true
                        flag_backupmode_or_restoremode_exitloop=true

                        break
                        ;;
                esac
                ;;
            "${TB_OPTIONS_M}")
                case "${tb_editmode_set}" in
                    "${TB_ON}")
                        #Append 'keyinput' to 'tb_keyinput_tot'
                        tb_keyinput_tot+="${keyinput}"
                        ;;
                    *)
                        #Move down and clean one line
                        movedown_and_clean__func "${TB_NUMOFLINES_1}"

                        #Set flags to true
                        flag_dircontent_handler_exitloop=true
                        flag_backupmode_or_restoremode_child_exitloop=true
                        flag_backupmode_or_restoremode_exitloop=true
                        flag_bootoptions_exitloop=true

                        break
                        ;;
                esac
                ;;
            "${TB_OPTIONS_Q}")
                case "${tb_editmode_set}" in
                    "${TB_ON}")
                        #Append 'keyinput' to 'tb_keyinput_tot'
                        tb_keyinput_tot+="${keyinput}"
                        ;;
                    *)
                        #Move down and clean one line
                        movedown_and_clean__func "${TB_NUMOFLINES_1}"

                        #Exit script
                        exit__func "${TB_EXITCODE_99}" "${TB_NUMOFLINES_2}"

                        break
                        ;;
                esac
                ;;
            "${TB_BACKSPACE}")
                case "${tb_editmode_set}" in
                    "${TB_OFF}")
                        break
                        ;;
                    *)
                        #Get the length of 'tb_keyinput_tot'
                        tb_keyinput_tot_len=${#tb_keyinput_tot}
                        if [[ ${tb_keyinput_tot_len} -gt 0 ]]; then #length > 0                    
                            #Remove one character from 'tb_keyinput_tot'
                            tb_keyinput_tot=$(backspace__func "${tb_keyinput_tot}")

                            #Initialize variable
                            keyinput_backspace_tmp="${TB_BACKSPACE}"

                            #Start and stay in the loop as long as 'keyinput_paste_tmp' is NOT an Empty String.
                            #Remarks:
                            #   In other words, for as long as BACKSPACE is being pressed within 0.05 seconds.
                            #   Also remove one character from 'tb_keyinput_tot'.
                            #   This loop is implemented to prevent (^H) from showing when pressing and holding BACKSPACE.
                            while [[ -n "${keyinput_backspace_tmp}" ]]
                            do
                                #Execute read-dialog and wait for input
                                #Remark:
                                #   This  has been implement to make PASTE of chars smoother.
                                read -N1 -t0.05 -rs keyinput_backspace_tmp

                                #Check if a BACKSPACE was pressed                                
                                if [[ "${keyinput_backspace_tmp}" == "${TB_BACKSPACE}" ]]; then #BACKSPACE was pressed
                                    #Remove one character from 'tb_keyinput_tot'
                                    tb_keyinput_tot=$(backspace__func "${tb_keyinput_tot}")
                                fi
                            done

                            #Set flag to 'true'
                            flag_print_tb_keyinput_tot_isenabled=true
                        else    #length = 0
                            #Move-right with 1 character
                            tput cuf 1
                        fi
                        ;;
                esac
                ;;
            "${TB_ESCAPEKEY}")
                #Get the function-key which was pressed
                funckey=$(functionKey_detection__func)
                if [[ "${funckey}" == "${TB_FUNC_F1}" ]]; then  #F1 was pressed
                    #1. Switch flag from 'ON' to 'OFF' or vice versa
                    #2. Update printable variable
                    if [[ "${tb_editmode_set}" == "${TB_ON}" ]]; then
                        tb_editmode_set="${TB_OFF}"

                        tb_editmode_set_printable="${tb_editmode_set_off_printable}"
                    else    #tb_editmode_set = TB_OFF
                        tb_editmode_set="${TB_ON}"

                        tb_editmode_set_printable="${tb_editmode_set_on_printable}"
                    fi

                    #Set flags to true
                    flag_dircontent_handler_exitloop=true

                    #Move down and clean one line
                    movedown_and_clean__func "${TB_NUMOFLINES_2}"
                fi

                break
                ;;
            "${TB_ENTER}")
                #Disable this option if 'editmode' is 'OFF'
                case "${tb_editmode_set}" in
                    "${TB_OFF}")
                        #Do nothing
                        break
                        ;;
                    *)
                        if [[ -n "${tb_keyinput_tot}" ]]; then
                            #Update variable
                            fpath="${tb_data_dstpath_set}/${tb_keyinput_tot}"

                            #Check if file-fullpath exists
                            if [[ -f "${fpath}" ]]; then
                                #Generate new file-fullpath
                                fpath_new=$(filename_generate_unique__func "${fpath}")

                                #Extract filename from 'fpath_new'
                                filename_new=$(basename "${fpath_new}")

                                #Generate message
                                printmsg="${TB_PRINT_UPDATE}: filename ${TB_FG_ORANGE_131}${tb_keyinput_tot}${TB_NOCOLOR} already exist. \n"
                                printmsg+="${TB_PRINT_UPDATE}: generated *new* filename ${TB_FG_GREEN_158}${filename_new}${TB_NOCOLOR}"

                                #Ask for confirmation
                                #Note: this function will pass the result to global variable 'tb_confirm_keyinput'
                                confirmation__func "${TB_READDIALOG_ACCEPT_AND_CONTINUE}" \
                                        "${TB_YN_REGEX}" \
                                        "${printmsg}"
                                case "${tb_confirm_keyinput}" in
                                    "${TB_OPTIONS_Y}")
                                            #Update global variable
                                            tb_data_dstfile_set="${fpath_new}"

                                            #Set flags to true
                                            flag_dircontent_handler_exitloop=true
                                            flag_backupmode_or_restoremode_child_exitloop=true                                        
                                        ;;
                                    *)
                                        flag_dircontent_handler_exitloop=true
                                        ;;                                        
                                esac
                            else    #fpath does not exist
                                #Update global variable
                                tb_data_dstfile_set="${fpath}"

                                #Set flags to true
                                flag_dircontent_handler_exitloop=true
                                flag_backupmode_or_restoremode_child_exitloop=true

                                #Print confirmed message
                                # dircontent_print_confirmed_input__sub "${readdialog_msg}" "${tb_keyinput_bck}"

                                #Move down and clean two lines
                                movedown_and_clean__func "${TB_NUMOFLINES_1}"
                            fi
                        fi

                        break
                        ;;
                esac
                ;;
            "${TB_TAB}")
                break
                ;;
            *)
                #Check if 'edit-mode' is 'ON' or 'OFF' and update 'tb_keyinput_tot'
                if [[ "${tb_editmode_set}" == "${TB_ON}" ]]; then
                    #Append 'keyinput' to 'tb_keyinput_tot'
                    tb_keyinput_tot+="${keyinput}"

                    #Get the length of 'tb_keyinput_tot' after appending the 1st character.
                    tb_keyinput_tot_len1=${#tb_keyinput_tot}

                    #Start and stay in the loop as long as 'keyinput_paste_tmp' is NOT an Empty String
                    #Remark:
                    #   The implementation of this loop make PASTING of a string with multiple characters smoother.
                    #   Remarks:
                    #       the choice of (-t) value has impact on the BACKSPACE.
                    keyinput_paste_tmp="${keyinput}"
                    while [[ -n "${keyinput_paste_tmp}" ]]
                    do
                        #Execute read-dialog and wait for input
                        #Remark:
                        #   This  has been implement to make PASTE of chars smoother.
                        read -N1 -t0.02 -rs keyinput_paste_tmp 2>/dev/null

                        #Append 'keyinput_paste_tmp' to 'tb_keyinput_tot'
                        tb_keyinput_tot+="${keyinput_paste_tmp}"
                    done
                    
                    #Get the length of 'tb_keyinput_tot' after appending the last character, which
                    #   was pasted within 0.02 seconds
                    tb_keyinput_tot_len2=${#tb_keyinput_tot}

                    flag_print_tb_keyinput_tot_isenabled=true
                else    #tb_editmode_set = TB_OFF
                    flag_print_tb_keyinput_tot_isenabled=false

                    #Do nothing
                    #In this case only the following menu-options: F1, b, h, m, q can be chosen.
                    break
                fi
                ;;
        esac
    done

    #Show cursor, enable keyboard-input, enable terminal refresh
    cursor_keyboard_termrefresh_enable__sub
}
dircontent_handler_srcpath_dstpath_select__sub() {
    local dir__input=${1}
    local dir_parent__input=${2}
    local outputtype__input=${3}
    local readdialog_msg1__input=${4}
    local readdialog_msg2__input=${5}
    local flag_back_option_isenabled__input=${6}
    local flag_dir_isfixed__input=${7}
    local flag_show_menuitem_index_isenabled__input=${8}
    local flag_dir_parent_isnot_tobe_used__input=${9}


    #Initalize variables
    local echomsg="${TB_EMPTYSTRING}"
    local echomsg_wo_color="${TB_EMPTYSTRING}"
    local isdevpart="${TB_EMPTYSTRING}"
    local keyinput="${TB_EMPTYSTRING}"
    local path_list_arr_selitem="${TB_EMPTYSTRING}"
    local path_list_arr_selitem_clean="${TB_EMPTYSTRING}"
    local path_bck="${TB_EMPTYSTRING}"
    local path_new="${TB_EMPTYSTRING}"
    local path_new_raw="${TB_EMPTYSTRING}"
    local printmsg="${TB_EMPTYSTRING}"

    local echomsg_wo_color_len=0
    local listpage_start_bck=0
    local path_list_arr_selindex=0
    local path_list_arr_selindex_max=0

    #Print the read-dialog
    printf "%s" "${readdialog_msg1__input}"

    #Backup cursor position
    tput sc

    while [[ 1 ]]
    do
        #Check if 'keyinput' is an Empty String
        #Remarks:
        #   1st iteration -> keyinput is Empty String,
        #       which means no key has been pressed yet.
        #   after the 1st iteration -> keyinput may contain data,
        #       which means that a key was pressed at a certain point in time.
        if [[ -n "${keyinput}" ]]; then #is NOT an Empty String
            moveback_numoflines=1
        else    #is Empty String
            moveback_numoflines=0
        fi

        #Print 'keyinput'
        printf "%s" "${keyinput}"
    
        #Reset variable
        keyinput="${TB_EMPTYSTRING}"

        #Show cursor, enable keyboard-input, enable terminal refresh
        cursor_keyboard_termrefresh_enable__sub

        #Execute read-dialog and wait for input
        read -N1 -rs keyinput

        #Hide cursor, disable keyboard-input, disable terminal refresh
        cursor_keyboard_termrefresh_disable__sub

        #Restore cursor position or move-back cursor 
        if [[ ${moveback_numoflines} -eq 0 ]]; then
            tput rc #restore
        else
            tput cub ${moveback_numoflines} #move-back
        fi


        case "${keyinput}" in
            "${TB_OPTIONS_LARROW}")
                #Backup variable
                listpage_start_bck=${tb_listpage_start}

                #Decrement variable
                tb_listpage_start=$(( listpage_start_bck - TB_LISTPAGE_LEN ))

                #Final action
                if [[ ${tb_listpage_start} -gt 0 ]]; then
                    #Set flag to true
                    flag_dircontent_handler_exitloop=true

                    #Move down and clean two lines
                    movedown_and_clean__func "${TB_NUMOFLINES_2}"

                    break
                else
                    tb_listpage_start=${listpage_start_bck}
                fi
                ;;
            "${TB_OPTIONS_RARROW}")
                #Backup variable
                listpage_start_bck=${tb_listpage_start}

                #Incrementvariable
                tb_listpage_start=$(( tb_listpage_start + TB_LISTPAGE_LEN ))

                #Final action
                if [[ ${tb_listpage_start} -le ${tb_path_list_arrlen} ]]; then
                    #Set flag to true
                    flag_dircontent_handler_exitloop=true

                    #Move down and clean two lines
                    movedown_and_clean__func "${TB_NUMOFLINES_2}"

                    break
                else
                    tb_listpage_start=${listpage_start_bck}
                fi
                ;;
            "${TB_OPTIONS_B}")
                if [[ "${flag_back_option_isenabled__input}" == true ]]; then
                    #Move down and clean one line
                    movedown_and_clean__func "${TB_NUMOFLINES_2}"

                    #Set flags to true
                    flag_dircontent_handler_exitloop=true
                    flag_backupmode_or_restoremode_child_exitloop=true
                    flag_go_back_onestep=true
                fi

                break
                ;;
            "${TB_OPTIONS_H}")
                #Move down and clean one line
                movedown_and_clean__func "${TB_NUMOFLINES_1}"

                #Set flags to true
                flag_dircontent_handler_exitloop=true
                flag_backupmode_or_restoremode_child_exitloop=true
                flag_backupmode_or_restoremode_exitloop=true

                break
                ;;
            "${TB_OPTIONS_M}")
                #Move down and clean one line
                movedown_and_clean__func "${TB_NUMOFLINES_1}"

                #Set flags to true
                flag_dircontent_handler_exitloop=true
                flag_backupmode_or_restoremode_exitloop=true
                flag_backupmode_or_restoremode_child_exitloop=true
                flag_bootoptions_exitloop=true

                break
                ;;
            "${TB_OPTIONS_P}")
                #Backup variable
                path_bck="${dir__input}"

                #Get the directory of fullpath 'path_bck'
                path_new=$(dirname "${dir__input}")

                #Check if 'dir__input' is alowed to be changed
                if [[ "${flag_dir_isfixed__input}" == true ]]; then #not allowed to be changed
                    break
                fi
                
                #Check if 'dir_parent__input' is part of parent directory 'path_new'
                #Note: 'dir_parent__input' can NOT be an Empty String
                if [[ $(substring_isfound_in_string__func "${path_new}" "${dir_parent__input}") == false ]] && \
                        [[ -n "${dir_parent__input}" ]]; then
                    break
                fi
                    
                #Check if 'path_new' is not the same as 'path_bck'
                if [[ "${path_new}" != "${path_bck}" ]]; then
                    #Reset variable
                    tb_listpage_start=1

                    #Update global variables
                    tb_data_path_set="${path_new}"

                    #Set flags to true
                    flag_dircontent_handler_exitloop=true

                    #Move down and clean one line
                    movedown_and_clean__func "${TB_NUMOFLINES_2}"

                    break
                fi
                ;;
            "${TB_OPTIONS_Q}")
                #Move down and clean one line
                movedown_and_clean__func "${TB_NUMOFLINES_1}"

                #Exit script
                exit__func "${TB_EXITCODE_99}" "${TB_NUMOFLINES_2}"
                ;;
            "${TB_OPTIONS_R}")
                #Backup variable
                path_bck="${dir__input}"

                #Update variable
                if [[ -n "${dir_parent__input}" ]]; then
                    path_new="${dir_parent__input}"
                else
                    path_new="${TB_SLASH}"
                fi

                #Check if 'dir__input' is allowed to be changed
                if [[ "${flag_dir_isfixed__input}" == true ]]; then #not allowed to be changed
                    break
                fi
                
                #Check if 'dir_parent__input' is part of parent directory 'path_new'
                #Note: 'dir_parent__input' can NOT be an Empty String
                if [[ $(substring_isfound_in_string__func "${path_new}" "${dir_parent__input}") == false ]] && \
                        [[ -n "${dir_parent__input}" ]]; then
                    break
                fi
                
                if [[ "${path_new}" != "${path_bck}" ]]; then
                    #Reset variable
                    tb_listpage_start=1

                    #Update global variables
                    tb_data_path_set="${path_new}"

                    #Set flags to true
                    flag_dircontent_handler_exitloop=true

                    #Move down and clean two lines
                    movedown_and_clean__func "${TB_NUMOFLINES_2}"

                    break
                fi
                ;;
            "${TB_BACKSPACE}")
                break
                ;;
            "${TB_ESCAPEKEY}")
                break
                ;;
            "${TB_ENTER}")
                #Check if 'dir_parent__input' is allowed to be selected
                if [[ "${flag_dir_parent_isnot_tobe_used__input}" == true ]] && \
                        [[ "${tb_data_path_set}" == "${dir_parent__input}" ]]; then
                    break
                fi

                #Set tb_data_srcpath_set based on 'outputtype__input' value
                case "${outputtype__input}" in
                    "${TB_BACKUPMODE_SRCPATH}")
                        isdevpart=$(echo "${tb_data_path_set}" | grep "${tb_dev_dir}")
                        #Check if 'tb_data_path_set' is a 'dev' partition
                        if [[ -z "${isdevpart}" ]]; then    #is not a dev-partition
                            break
                        fi
                        tb_data_srcpath_set="${tb_data_path_set}"
                        ;;
                    "${TB_BACKUPMODE_DSTDIR}")
                        #Check if 'tb_data_path_set' is a directory
                        if [[ ! -d "${tb_data_path_set}" ]]; then   #is not a directory
                            break
                        fi
                        tb_data_dstpath_set="${tb_data_path_set}"
                        ;;
                    "${TB_BACKUPMODE_DSTFILE}")
                        #Check if 'tb_data_path_set' is a file
                        if [[ ! -f "${tb_data_path_set}" ]]; then   #is not a file
                            break
                        fi
                        tb_data_dstpath_set="${tb_data_path_set}"
                        ;;
                    "${TB_RESTOREMODE_SRCFILE}")
                        #Check if 'tb_data_path_set' is a file
                        if [[ ! -f "${tb_data_path_set}" ]]; then   #is not a file
                            break
                        fi
                        tb_data_srcpath_set="${tb_data_path_set}"
                        ;;
                    "${TB_RESTOREMODE_DSTPATH}")
                        isdevpart=$(echo "${tb_data_path_set}" | grep "${tb_dev_dir}")
                        #Check if 'tb_data_path_set' is a 'dev' partition
                        if [[ -z "${isdevpart}" ]]; then    #is not a dev-partition
                            break
                        fi
                        tb_data_dstpath_set="${tb_data_path_set}"
                        ;;
                    *)
                        #Set messages
                        whatmsg="unknown input value ${TB_FG_GREY_246}outputtype__input${TB_NOCOLOR} = ${TB_FG_GREY_246}${outputtype__input}${TB_NOCOLOR}"
                        wheremsg="subroutine: ${TB_FG_GREY_246}dircontent_handler_srcpath_dstpath_select__sub${TB_NOCOLOR}"

                        #Print error-message
                        print_errormsg__sub "${whatmsg}" "${wheremsg}"

                        #Set flag to 'true'
                        flag_dircontent_handler_exitloop=true

                        break
                        ;;
                esac

                #Set flags to true
                flag_dircontent_handler_exitloop=true
                flag_backupmode_or_restoremode_child_exitloop=true

                #Move down and clean two lines
                movedown_and_clean__func "${TB_NUMOFLINES_2}"

                break
                ;;
            "${TB_TAB}")
                break
                ;;
            *)
                #Backup variable
                path_bck="${dir__input}"

                if [[ $(isNumeric__func "${keyinput}") == true ]]; then #is numeric             
                    if [[ ${tb_path_list_arrlen} -gt 0 ]]; then
                        #Only calculate 'path_list_arr_selindex_max' if 'tb_path_list_arrlen > 0'
                        path_list_arr_selindex_max=$((tb_path_list_arrlen - 1))
                    else    #tb_path_list_arrlen = 0
                        break
                    fi
                    
                    if [[ ${keyinput} -le ${path_list_arr_selindex_max} ]]; then
                        #Get array-index
                        path_list_arr_selindex=$((tb_listpage_start + keyinput - 1))

                        #Update variable
                        path_list_arr_selitem="${tb_path_list_arr[path_list_arr_selindex]}"

                        #Strip off '[d]' (if present)
                        path_list_arr_selitem_clean=$(echo "${path_list_arr_selitem}" | sed "s/${TB_SED_PATTERN_LBRACKET_D_RBRACKET}//g")

                        #Update variable
                        if [[ "${flag_dir_isfixed__input}" == true ]]; then #not allowed
                            path_new_raw="${dir_parent__input}/${path_list_arr_selitem_clean}"
                        else
                            path_new_raw="${dir__input}/${path_list_arr_selitem_clean}"
                        fi

                        #Remove double slashes
                        path_new=$(echo "${path_new_raw}" | sed 's/\/\//\//g')

                        #Check if path has changed
                        #Remark:
                        #   If false, then it means that data do NOT need to be refreshed.
                        if [[ "${path_new}" == "${dir__input}" ]]; then
                            break
                        fi

                        #Check if 'path_new' is a directory
                        if [[ -d "${path_new}" ]]; then #is a directory
                            #Check if flag is set to NOT allow a directory change
                            if [[ "${flag_dir_isfixed__input}" == true ]]; then #not allowed to be changed
                                #Set values back to 'path_bck'
                                tb_data_path_set="${path_bck}"
                            else
                                #Update global variables
                                tb_data_path_set="${path_new}"

                                #Backup 'keyinput'
                                # tb_keyinput_bck="${keyinput}"

                                #Set flag to 'true'
                                flag_dircontent_handler_exitloop=true

                                #Reprint selected path and menu-options
                                #Remark:
                                #   This subroutine will pass a return value 
                                #       to the global variable 'tb_exitcode'.
                                dircontent_reprint_selectedpath__sub "${path_new}" \
                                        "${outputtype__input}"
                                if [[ ${tb_exitcode} -ne 0 ]]; then
                                    flag_dircontent_handler_exitloop=true

                                    break
                                fi
                            fi

                            #Print 'keyinput' before exiting this loop
                            #Remark:
                            #   If this print is not executed, then the last input
                            #       value 'keyinput' will not be shown on screen.
                            printf "%s" "${keyinput}"

                            #Move down and clean one line
                            movedown_and_clean__func "${TB_NUMOFLINES_2}"

                            break
                        else    #is a file or dev-partition
                            #Update global variables
                            tb_data_path_set="${path_new}"

                            #Backup 'keyinput'
                            # tb_keyinput_bck="${keyinput}"

                            #Reprint selected path and menu-options
                            #Remark:
                            #   This subroutine will pass a return value 
                            #       to the global variable 'tb_exitcode'.
                            dircontent_reprint_selectedpath__sub "${path_new}" \
                                    "${outputtype__input}"
                            if [[ ${tb_exitcode} -ne 0 ]]; then
                                flag_dircontent_handler_exitloop=true

                                break
                            fi
                        fi  #end of: if [[ -d "${path_new}" ]]
                    else    #keyinput > path_list_arr_selindex_max
                        break
                    fi  #end of: if [[ ${keyinput} -le ${path_list_arr_selindex_max} ]]
                else    #is NOT numeric
                    break
                fi  #end of: if [[ $(isNumeric__func "${keyinput}") == true ]]
                ;;
        esac
    done

    #Show cursor, enable keyboard-input, enable terminal refresh
    cursor_keyboard_termrefresh_enable__sub
}
dircontent_reprint_selectedpath__sub() {
    #This subroutine will pass a return value to the global variable 'tb_exitcode'

    #Input args
    local path_sel__input=${1}
    local outputtype__input=${2}

    #Define variables
    local numofcols_to_moveleft=0
    local numoflines_to_moveup=0
    local path_sel_compact="${TB_EMPTYSTRING}"

    #Initialize variables
    tb_exitcode=0

	#Save cursor position
	tput sc

    #Hide cursor, disable keyboard-input, disable terminal refresh
    cursor_keyboard_termrefresh_disable__sub

	#Move-up to the 'selected path info' field
    case "${outputtype__input}" in
        "${TB_BACKUPMODE_DSTDIR}")
            numoflines_to_moveup=${TB_NUMOFLINES_9}
            ;;
        "${TB_BACKUPMODE_DSTFILE}")
            numoflines_to_moveup=${TB_NUMOFLINES_9}
            ;;
        "${TB_BACKUPMODE_SRCPATH}")
            numoflines_to_moveup=${TB_NUMOFLINES_8}
            ;;
        "${TB_RESTOREMODE_DSTPATH}")
            numoflines_to_moveup=${TB_NUMOFLINES_9}
            ;;
        "${TB_RESTOREMODE_SRCFILE}")
            numoflines_to_moveup=${TB_NUMOFLINES_8}
            ;;
        *)
            #Set messages
            whatmsg="unknown input value ${TB_FG_GREY_246}outputtype__input${TB_NOCOLOR} = ${TB_FG_GREY_246}${outputtype__input}${TB_NOCOLOR}"
            wheremsg="subroutine: ${TB_FG_GREY_246}dircontent_reprint_selectedpath__sub${TB_NOCOLOR}"

            #Print error-message
            print_errormsg__sub "${whatmsg}" "${wheremsg}"

            #Set 'tb_exitcode'
            #Remark:
            #   This is necessary to exit the while-loop in subroutine 'dircontent_handler__sub'
            tb_exitcode=99

            return 0;
            ;;
    esac

    #Move-up with the specified number of lines 'numoflines_to_moveup'
    tput cuu ${numoflines_to_moveup}

    #Get the total number of columns of the current terminal window
    numofcols_to_moveleft=$(tput cols)

    #Move-left with the specified number of column 'numofcols_to_moveleft'
    tput cub "${numofcols_to_moveleft}"

    #Compact 'path_sel__input' (if necessary)
    path_sel_compact=$(compact_string__func "${path_sel__input}" \
            "${TB_TABLEWIDTH}" \
            "${TB_BASENAME_COMPACT_LEN_MIN}")

    #Reprint selected path
    printf "%s" "${TB_FOURSPACES}${TB_FG_BLUE_45}${path_sel_compact}${TB_NOCOLOR}" && tput el

    #Show cursor, enable keyboard-input, enable terminal refresh
    cursor_keyboard_termrefresh_enable__sub

    #Restore cursor position and clean until end of line
    tput rc
}

print_errormsg__sub() {
    #Input args
    local whatmsg__input="${1}"
    local wheremsg__input="${2}"

    #Move-down and clean 3 lines
    movedown_and_clean__func "${TB_NUMOFLINES_3}"

    #Set 'printmsg'
    printmsg="${TB_PRINT_ERROR}: Ooops...something unexpected happened...\n"
    printmsg+="${TB_PRINT_WHAT}: ${whatmsg__input}\n"
    printmsg+="${TB_PRINT_WHERE}: ${wheremsg__input}"

    #Print message
    echo -e "${printmsg}"

    #Move-down 1 line
    movedown_and_clean__func "${TB_NUMOFLINES_1}"
}

dircontent_print_confirmed_input__sub() {
    #Input args
    local readdialog_msg__input=${1}
    local keyinput__input=${2}

    #Get lengths
    local readdialog_msg_len=$(get_stringlen_wo_color__func "${readdialog_msg__input}")
    local keyinput_len=${#keyinput__input}

    #Go to the expected cursor position
    tput cub 1

    #Print 'keyinput__input'
    printf "%s" "${keyinput__input}"
}

tb_init_bootargs_tmp_write__sub() {
    #Input args
    local string__input=${1}

    #Remove file (if present)
    remove_file__func "${tb_init_bootargs_tmp_fpath}"

    #Write to file
    echo "${string__input}" | tee "${tb_init_bootargs_tmp_fpath}"  >/dev/null
}



#---SECTION MAIN-MENU
mainmenu_checkif_user_is_root__func() {
    #Define variables
    local errormsg="${TB_PRINT_ERROR}: Please run as 'sudoer' or 'root'\n"

    if [[ $EUID != 0 ]]; then
        movedown_and_clean__func "${TB_NUMOFLINES_2}"
        echo -e "${errormsg}"
        movedown_and_clean__func "${TB_NUMOFLINES_1}"

        exit "${TB_EXITCODE_99}"
    fi
}
mainmenu_extract_info__func() {
    #Remark:
    #   This function will pass values to global variables 'tb_overlaymode_set' and 'tb_overlaymode_set_printable'
    extract_overlaymode_info__func

    #Remark:
    #   This function will pass values to global variables 'tb_bootoptions_set' and 'tb_bootoptions_set_printable'
    extract_bootoptions_info__func

    #Remark:
    #   This function will pass values to global variables 'tb_ispboootbin_bootseq_set' and 'tb_ispboootbin_bootseq_printable'
    extract_ispboootbin_bootseq_info__func
}
mainmenu_print_title__sub() {
    print_duplicate_char__func "${TB_DASH}" "${TB_TABLEWIDTH}" "${TB_NOCOLOR}"
    print_leading_trailing_strings_on_opposite_sides__func "${TB_TITLE_TB_INIT_SH}" \
            "${TB_EMPTYSTRING}" \
            "${TB_TABLEWIDTH}"
    print_duplicate_char__func "${TB_DASH}" "${TB_TABLEWIDTH}" "${TB_NOCOLOR}"
}
mainmenu_print_body__sub() {
    #Update 'print_menuitem_1', 'print_menuitem_2, 'print_menuitem_3' based on
    #   whether 'tb_proc_cmdline_tb_overlay_get' is an Empty String or Not.
    #In other words, whether 'tb_overlay' is found in '/proc/cmdline' or not.
    local print_menuitem_1="${TB_EMPTYSTRING}"
    local print_menuitem_2="${TB_EMPTYSTRING}"
    local print_menuitem_3="${TB_EMPTYSTRING}"

    if [[ -z "${tb_proc_cmdline_tb_overlay_get}" ]]; then
        print_menuitem_1="${TB_FG_GREY_246}"
        print_menuitem_2="${TB_FG_GREY_246}"
        print_menuitem_3="${TB_FG_GREY_246}"
    fi
    
    print_menuitem_1+="${TB_ITEMNUM_1}. ${TB_MENUITEM_OVERLAYMODE} "
    if [[ -z "${tb_proc_cmdline_tb_overlay_get}" ]]; then
        print_menuitem_2+="${TB_ITEMNUM_2}. ${TB_MENU_WO_NOCOLOR}"
        print_menuitem_3+="${TB_ITEMNUM_3}. ${TB_MENU_WO_NOCOLOR}"
    else
        print_menuitem_2+="${TB_ITEMNUM_2}. ${TB_MENU}"
        print_menuitem_3+="${TB_ITEMNUM_3}. ${TB_MENU}"
    fi

    if [[ -z "${tb_proc_cmdline_tb_overlay_get}" ]]; then
        tb_overlaymode_set_printable="${TB_MODE_DISABLED}"
        tb_bootoptions_set_printable="${TB_MODE_DISABLED}"
        tb_ispboootbin_bootseq_printable="${TB_MODE_ISPBOOOTBIN_BOOTSEQ_SDUSB0USB1}"
    fi

    print_menuitem_1+="(${tb_overlaymode_set_printable})"
    print_menuitem_2+="${TB_MENUITEM_BOOTOPTIONS} (${tb_bootoptions_set_printable})"
    print_menuitem_3+="${TB_MENUITEM_ISPBOOOTBIN_BOOTSEQ} (${tb_ispboootbin_bootseq_printable})"

    if [[ -z "${tb_proc_cmdline_tb_overlay_get}" ]]; then
        print_menuitem_1+="${TB_NOCOLOR}"
        print_menuitem_2+="${TB_NOCOLOR}"
        print_menuitem_3+="${TB_NOCOLOR}"
    fi

    #Print body
    print_menuitem__func "${TB_FOURSPACES}" \
            "${TB_EMPTYSTRING}" \
            "${print_menuitem_1}" \
            "${TB_EMPTYSTRING}"
    print_menuitem__func "${TB_FOURSPACES}" \
            "${TB_EMPTYSTRING}" \
            "${print_menuitem_2}" \
            "${TB_EMPTYSTRING}"
    print_menuitem__func "${TB_FOURSPACES}" \
            "${TB_EMPTYSTRING}" \
            "${print_menuitem_3}" \
            "${TB_EMPTYSTRING}"
    print_duplicate_char__func "${TB_DASH}" "${TB_TABLEWIDTH}" "${TB_NOCOLOR}"
    print_menuitem__func "${TB_FOURSPACES}" \
            "${TB_OPTIONS_R}" \
            "${TB_OPTIONS_REBOOT}" \
            "${TB_EMPTYSTRING}"
    print_menuitem__func "${TB_FOURSPACES}" \
            "${TB_OPTIONS_Q}" \
            "${TB_OPTIONS_QUIT_CTRL_C}" \
            "${TB_EMPTYSTRING}"
    print_duplicate_char__func "${TB_DASH}" "${TB_TABLEWIDTH}" "${TB_NOCOLOR}"
}
mainmenu_print_legend__sub() {
    #Print
    print_menuitem__func "${TB_EMPTYSTRING}" \
            "${TB_EMPTYSTRING}" \
            "${TB_LEGEND}" \
            "${TB_EMPTYSTRING}"
    print_menuitem__func "${TB_FOURSPACES}" \
            "${TB_EMPTYSTRING}" \
            "${TB_LEGEND_SAME_W_DESCRIPTION}" \
            "${TB_EMPTYSTRING}"
    print_menuitem__func "${TB_FOURSPACES}" \
            "${TB_EMPTYSTRING}" \
            "${TB_LEGEND_NEW_W_DESCRIPTION}" \
            "${TB_EMPTYSTRING}"
    print_menuitem__func "${TB_FOURSPACES}" \
            "${TB_EMPTYSTRING}" \
            "${TB_LEGEND_NEW_PRIORITY_W_DESCRIPTION}" \
            "${TB_EMPTYSTRING}"
    print_duplicate_char__func "${TB_DASH}" "${TB_TABLEWIDTH}" "${TB_NOCOLOR}"
}
mainmenu_print_remark__sub() {
    if [[ "${tb_overlaymode_tag}" == "${TB_LEGEND_SAME}" ]] && [[ "${tb_bootoptions_status}" == "${TB_LEGEND_SAME}" ]]; then
        return 0;
    fi

    #Print
    print_menuitem__func "${TB_EMPTYSTRING}" \
            "${TB_EMPTYSTRING}" \
            "${TB_REMARKS}" \
            "${TB_EMPTYSTRING}"
    print_menuitem__func "${TB_FOURSPACES}" \
            "${TB_EMPTYSTRING}" \
            "${TB_REMARK_A_REBOOT_IS_REQUIRED_FOR_THE_CHANGE_TO_TAKE_EFFECT}" \
            "${TB_EMPTYSTRING}"
    print_duplicate_char__func "${TB_DASH}" "${TB_TABLEWIDTH}" "${TB_NOCOLOR}"
}
mainmenu_readdialog_choice__sub() {
    #Define and initialize variables
    local regex="${TB_MAINMENU_MYCHOICE_REGEX}"

    #Update 'regex' based on whether 'tb_proc_cmdline_tb_overlay_get' is an Empty String or Not.
    #In other words, whether 'tb_overlay' is found in '/proc/cmdline' or not.
    if [[ -z "${tb_proc_cmdline_tb_overlay_get}" ]]; then
        regex="${TB_RQ_REGEX}"
    fi
    
    while [[ 1 ]]
    do
        #Select an option
        read -N1 -r -p "${TB_READDIALOG_CHOOSE_AN_OPTION}" tb_mainmenu_mychoice
        # movedown_and_clean__func "${TB_NUMOFLINES_1}"

        #Only continue if a valid option is selected
        if [[ ! -z ${tb_mainmenu_mychoice} ]]; then
            if [[ ${tb_mainmenu_mychoice} =~ ${regex} ]]; then
                movedown_and_clean__func "${TB_NUMOFLINES_1}"

                break
            else
                if [[ ${tb_mainmenu_mychoice} == ${TB_ENTER} ]]; then
                    moveup_and_clean__func "${TB_NUMOFLINES_1}"                    
                else
                    moveup_and_clean__func "${TB_NUMOFLINES_0}"
                fi

                # readdialog_clean_buffer__func
            fi
        else
            moveup_and_clean__func "${TB_NUMOFLINES_0}"

            # readdialog_clean_buffer__func
        fi
    done
}
mainmenu_readdialog_action__sub() {
    #Goto the selected option
    case ${tb_mainmenu_mychoice} in
        1)
            overlaymode_toggle__sub
            ;;
        2)
            bootoptions__sub
            ;;
        3)
            ispboootbin_bootseqmenu__sub
            ;;
        r)
            reboot__sub
            ;;
        q)
            exit__func "${TB_EXITCODE_99}" "${TB_NUMOFLINES_2}"
            ;;
    esac
}



#---SECTION: OVERLAY-MODE TOGGLE
overlaymode_toggle__sub() {
    #Update 'tb_rootfs_ro_set' based on 'tb_overlaymode_set' value.
    #Remarks:
    #   1. 
    #   2. In file 'tb_init_bootargs_cfg_fpath' will be validated again, and
    #       if needed, removed in function 'extract_overlaymode_info__func'
    if [[ "${tb_overlaymode_set}" == "${TB_MODE_PERSISTENT}" ]]; then   #currently 'tb_overlaymode_set = TB_MODE_NONPERSISTENT'
        tb_rootfs_ro_set="${TB_ROOTFS_RO_IS_TRUE}"
    else    #currently 'tb_overlaymode_set = TB_MODE_PERSISTENT'
        tb_rootfs_ro_set="${TB_ROOTFS_RO_IS_NULL}"
    fi

    #Write to file
    echo "${tb_rootfs_ro_set}" | tee "${tb_init_bootargs_cfg_fpath}"  >/dev/null
}



#---SECTION: BOOT-INTO-MENU
bootoptions__sub() {
    while [[ 1 ]]
    do
        #Initialize variables
        flag_bootoptions_exitloop=false

        #Print header
        tibbo_print_title__sub    

        #Print bootinto menutitle
        bootoptions_title_print__sub

        #Print body
        bootoptions_body_print__sub

        #Print remark
        bootoptions_remark_print__sub

        #Show read-dialog (loop)
        #Note: result is passed to global variable 'tb_bootoptions_mychoice'
        bootoptions_readdialog_choice__sub

        #Take action
        bootoptions_readdialog_action__sub

        #Check if a flag was given to exit loop
        if [[ "${flag_bootoptions_exitloop}" == true ]]; then
            break
        fi
    done
}
bootoptions_title_print__sub() {
    print_duplicate_char__func "${TB_DASH}" "${TB_TABLEWIDTH}" "${TB_NOCOLOR}"
    print_leading_trailing_strings_on_opposite_sides__func "${TB_TITLE_BOOTINTO}" \
            "${TB_EMPTYSTRING}" \
            "${TB_TABLEWIDTH}"
    print_duplicate_char__func "${TB_DASH}" "${TB_TABLEWIDTH}" "${TB_NOCOLOR}"
}
bootoptions_body_print__sub() {
    #Define and initialize variables
    local print_cleanboot="${TB_MODE_CLEAN_BOOT}"
    local print_backupmode="${TB_MODE_BACKUPMODE}"
    local print_restoremode="${TB_MODE_RESTOREMODE}"
    local print_disabled="${TB_MODE_DISABLED}"

    #Extract 'bootinto' information
    extract_bootoptions_info__func

    #Update variables (if appliable)
    if [[ "${tb_bootoptions_set}" != "${TB_MODE_CLEAN_BOOT}" ]]; then
        print_cleanboot="${TB_FG_GREY_246}${print_cleanboot} (false)${TB_NOCOLOR}"
    else
        print_cleanboot="${print_cleanboot} (true)"
    fi
    if [[ "${tb_bootoptions_set}" != "${TB_MODE_BACKUPMODE}" ]]; then
        print_backupmode="${TB_FG_GREY_246}${print_backupmode} (false)${TB_NOCOLOR}"
    else
        print_backupmode="${print_backupmode} (true)"
    fi
    if [[ "${tb_bootoptions_set}" != "${TB_MODE_RESTOREMODE}" ]]; then
        print_restoremode="${TB_FG_GREY_246}${print_restoremode} (false)${TB_NOCOLOR}"
    else
        print_restoremode="${print_restoremode} (true)"
    fi
    if [[ "${tb_bootoptions_set}" == "${TB_MODE_CLEAN_BOOT}" ]] || \
            [[ "${tb_bootoptions_set}" == "${TB_MODE_BACKUPMODE}" ]] || \
            [[ "${tb_bootoptions_set}" == "${TB_MODE_RESTOREMODE}" ]]; then
        print_disabled="${TB_FG_GREY_246}${print_disabled}${TB_NOCOLOR}"
    fi

    #Print
    print_menuitem__func "${TB_FOURSPACES}" \
            "${TB_ITEMNUM_1}" \
            "${print_cleanboot}" \
            "${TB_EMPTYSTRING}"
    print_menuitem__func "${TB_FOURSPACES}" \
            "${TB_ITEMNUM_2}" \
            "${print_backupmode}" \
            "${TB_EMPTYSTRING}"
    print_menuitem__func "${TB_FOURSPACES}" \
            "${TB_ITEMNUM_3}" \
            "${print_restoremode}" \
            "${TB_EMPTYSTRING}"
    print_menuitem__func "${TB_FOURSPACES}" \
            "${TB_ITEMNUM_4}" \
            "${print_disabled}" \
            "${TB_EMPTYSTRING}"
    print_duplicate_char__func "${TB_DASH}" "${TB_TABLEWIDTH}" "${TB_NOCOLOR}"
    print_menuitem__func "${TB_FOURSPACES}" \
            "${TB_OPTIONS_M}" \
            "${TB_OPTIONS_MAIN}" \
            "${TB_EMPTYSTRING}"
    print_menuitem__func "${TB_FOURSPACES}" \
            "${TB_OPTIONS_Q}" \
            "${TB_OPTIONS_QUIT_CTRL_C}" \
            "${TB_EMPTYSTRING}"
    print_duplicate_char__func "${TB_DASH}" "${TB_TABLEWIDTH}" "${TB_NOCOLOR}"
}
bootoptions_remark_print__sub() {
    if [[ ! -s "${tb_init_bootargs_tmp_fpath}" ]]; then
        return 0;
    fi

    if [[ "${tb_bootoptions_set}" == "${TB_MODE_CLEAN_BOOT}" ]]; then
        return 0;
    fi

    #Extract 'if' and 'of'
    extract_if_and_of_from_string__func

    #Print
    print_menuitem__func "${TB_EMPTYSTRING}" \
            "${TB_EMPTYSTRING}" \
            "${TB_REMARKS}" \
            "${TB_EMPTYSTRING}"
    print_menuitem__func "${TB_EMPTYSTRING}" \
            "${TB_EMPTYSTRING}" \
            "${tb_bootoptions_remarks}" \
            "${TB_EMPTYSTRING}"
    print_duplicate_char__func "${TB_DASH}" "${TB_TABLEWIDTH}" "${TB_NOCOLOR}"
}
bootoptions_readdialog_choice__sub() {
    while [[ 1 ]]
    do
        #Select an option
        read -N1 -r -p "${TB_READDIALOG_CHOOSE_AN_OPTION}" tb_bootoptions_mychoice

        #Only continue if a valid option is selected
        if [[ ! -z ${tb_bootoptions_mychoice} ]]; then
            if [[ ${tb_bootoptions_mychoice} =~ ${TB_BOOTINTO_MYCHOICE_REGEX} ]]; then
                movedown_and_clean__func "${TB_NUMOFLINES_1}"

                break
            else
                if [[ ${tb_bootoptions_mychoice} == ${TB_ENTER} ]]; then
                    moveup_and_clean__func "${TB_NUMOFLINES_1}"                    
                else
                    moveup_and_clean__func "${TB_NUMOFLINES_0}"
                fi

                # readdialog_clean_buffer__func
            fi
        else
            moveup_and_clean__func "${TB_NUMOFLINES_0}"

            # readdialog_clean_buffer__func
        fi
    done
}
bootoptions_readdialog_action__sub() {
    #Goto the selected option
    case ${tb_bootoptions_mychoice} in
        1)
            bootoptions_safemode__sub
            ;;
        2)
            bootoptions_backupmode__sub
            ;;
        3)
            bootoptions_restoremode__sub
            ;;
        4)
            bootoptions_disable__sub
            ;;
        m)
            flag_bootoptions_exitloop=true;
            ;;
        q)
            exit__func "${TB_EXITCODE_99}" "${TB_NUMOFLINES_2}"
            ;;
    esac
}
bootoptions_safemode__sub() {
    #Update GLOBEL variable
    tb_bootoptions_set="${TB_NOBOOT_IS_TRUE}"

    tb_init_bootargs_tmp_write__sub "${tb_bootoptions_set}"

    # #Remove file (if present)
    # remove_file__func "${tb_init_bootargs_tmp_fpath}"

    # #Update 'tb_rootfs_ro_set' based on 'tb_overlaymode_set' value.
    # tb_bootoptions_set="${TB_NOBOOT_IS_TRUE}"

    # #Write to file
    # echo "${tb_bootoptions_set}" | tee "${tb_init_bootargs_tmp_fpath}" 2>/dev/null
}



#---SECTION: BACKUP-MODE
bootoptions_backupmode__sub() {
    #Define constants
    local PHASE_BOOTOPTIONS_BACKUPMODE_SRC_DEVPART=10
    local PHASE_BOOTOPTIONS_BACKUPMODE_DST_DIR=20
    local PHASE_BOOTOPTIONS_BACKUPMODE_COMPARE_SIZES=22
    local PHASE_BOOTOPTIONS_BACKUPMODE_DST_FILE=23
    local PHASE_BOOTOPTIONS_BACKUPMODE_EXIT=100

    #Define variables
    local phase="${PHASE_BOOTOPTIONS_BACKUPMODE_SRC_DEVPART}"

    #Initialize variables
    tb_data_dstpath_set="${TB_EMPTYSTRING}"
    tb_data_srcpath_set="${TB_EMPTYSTRING}"
    tb_data_dstfile_set="${TB_EMPTYSTRING}"

    #Start loop
    while [[ 1 ]]
    do
        case "${phase}" in
            "${PHASE_BOOTOPTIONS_BACKUPMODE_SRC_DEVPART}")
                bootoptions_backupmode_srcpath_select__sub

                if [[ "${flag_backupmode_or_restoremode_exitloop}" == true ]]; then
                    phase="${PHASE_BOOTOPTIONS_BACKUPMODE_EXIT}"
                else
                    phase="${PHASE_BOOTOPTIONS_BACKUPMODE_DST_DIR}"
                fi
                ;;
            "${PHASE_BOOTOPTIONS_BACKUPMODE_DST_DIR}")
                bootoptions_backupmode_dstdir_select__sub

                if [[ "${flag_go_back_onestep}" == true ]]; then
                    phase="${PHASE_BOOTOPTIONS_BACKUPMODE_SRC_DEVPART}"
                else
                    if [[ "${flag_backupmode_or_restoremode_exitloop}" == true ]]; then
                        phase="${PHASE_BOOTOPTIONS_BACKUPMODE_EXIT}"
                    else
                        phase="${PHASE_BOOTOPTIONS_BACKUPMODE_COMPARE_SIZES}"
                    fi
                fi
                ;;
            "${PHASE_BOOTOPTIONS_BACKUPMODE_COMPARE_SIZES}")
                bootoptions_backupmode_compare_disksize__sub

                if [[ "${flag_go_back_onestep}" == true ]]; then
                    phase="${PHASE_BOOTOPTIONS_BACKUPMODE_DST_DIR}"
                else
                    phase="${PHASE_BOOTOPTIONS_BACKUPMODE_DST_FILE}"
                fi
                ;;
            "${PHASE_BOOTOPTIONS_BACKUPMODE_DST_FILE}")
                bootoptions_backupmode_dstfile_input__sub

                if [[ "${flag_go_back_onestep}" == true ]]; then
                    phase="${PHASE_BOOTOPTIONS_BACKUPMODE_DST_DIR}"
                else
                    phase="${PHASE_BOOTOPTIONS_BACKUPMODE_EXIT}"
                fi
                ;;
            "${PHASE_BOOTOPTIONS_BACKUPMODE_EXIT}")
                bootoptions_backupmode_exit__sub

                break
                ;;
        esac
    done
}
bootoptions_backupmode_srcpath_select__sub() {
    #Define and initialize variables
    local flag_back_option_isenabled=false
    local flag_dir_isfixed=true
    local flag_show_menuitem_index_isenabled=true
    local flag_type_isdir=false
    local flag_type_isfile=false
    local flag_dir_parent_isnot_tobe_used=true

    #Initialize global variables
    tb_editmode_set="${TB_OFF}"
    tb_data_path_set=${tb_dev_dir}
    # tb_keyinput_bck="${TB_EMPTYSTRING}"
    tb_keyinput_tot="${TB_EMPTYSTRING}"
    tb_listpage_start=1

    tb_path_list_arr=()
    tb_path_list_arrlen=0

    #Start loop
    while [[ 1 ]]
    do
        #Print header, body, menu-options
        dircontent_data_extract_and_show__sub "${tb_data_path_set}" \
                "${tb_dev_dir}" \
                "${TB_PATTERN_MMCBLK0}" \
                "${tb_listpage_start}" \
                "${TB_BACKUPMODE_SRCPATH}" \
                "${flag_back_option_isenabled}" \
                "${flag_dir_isfixed}" \
                "${flag_type_isdir}" \
                "${flag_type_isfile}" \
                "${flag_show_menuitem_index_isenabled}"

        #Take action
        dircontent_handler__sub "${tb_data_path_set}" \
                "${tb_dev_dir}" \
                "${TB_BACKUPMODE_SRCPATH}"  \
                "${TB_READDIALOG_CHOOSE_AN_OPTION_AND_PRESS_ENTER}" \
                "${TB_EMPTYSTRING}" \
                "${flag_back_option_isenabled}" \
                "${flag_dir_isfixed}" \
                "${flag_show_menuitem_index_isenabled}" \
                "${flag_dir_parent_isnot_tobe_used}"

        if [[ "${flag_backupmode_or_restoremode_child_exitloop}" == true ]]; then
            break
        fi
    done
}
bootoptions_backupmode_dstdir_select__sub() {
    #Define variables
    local flag_back_option_isenabled=true
    local flag_dir_isfixed=false
    local flag_show_menuitem_index_isenabled=true
    local flag_type_isdir=true
    local flag_type_isfile=false
    local flag_dir_parent_isnot_tobe_used=true

    #Initialize global variables
    tb_editmode_set="${TB_OFF}"
    tb_data_path_set=${tb_media_dir}
    # tb_keyinput_bck="${TB_EMPTYSTRING}"
    tb_keyinput_tot="${TB_EMPTYSTRING}"
    tb_listpage_start=1

    tb_path_list_arr=()
    tb_path_list_arrlen=0

    #Start loop
    while [[ 1 ]]
    do
        #Print header, body, menu-options
        dircontent_data_extract_and_show__sub "${tb_data_path_set}" \
                "${tb_media_dir}" \
                "${TB_EMPTYSTRING}" \
                "${tb_listpage_start}" \
                "${TB_BACKUPMODE_DSTDIR}" \
                "${flag_back_option_isenabled}" \
                "${flag_dir_isfixed}" \
                "${flag_type_isdir}" \
                "${flag_type_isfile}" \
                "${flag_show_menuitem_index_isenabled}"

        #Take action
        dircontent_handler__sub "${tb_data_path_set}" \
                "${tb_media_dir}" \
                "${TB_BACKUPMODE_DSTDIR}"  \
                "${TB_READDIALOG_CHOOSE_AN_OPTION_AND_PRESS_ENTER}" \
                "${TB_EMPTYSTRING}" \
                "${flag_back_option_isenabled}" \
                "${flag_dir_isfixed}" \
                "${flag_show_menuitem_index_isenabled}" \
                "${flag_dir_parent_isnot_tobe_used}"

        if [[ "${flag_backupmode_or_restoremode_child_exitloop}" == true ]]; then
            break
        fi
    done
}
bootoptions_backupmode_compare_disksize__sub() {    
    #Note: this subroutine passes the result to the global variable 'tb_disksizes_compare_result'
    diskspaces_compare__func "${tb_data_srcpath_set}" "${tb_data_dstpath_set}" "${TB_TYPE_BACKUP}"

    if [[ "${tb_disksizes_compare_result}" == "${TB_DISKSIZE_COMPARE_RESULT_SUFFICIENT}" ]]; then
        flag_go_back_onestep=false
    else    #tb_disksizes_compare_result = TB_DISKSIZE_COMPARE_RESULT_INSUFFICIENT
        flag_go_back_onestep=true
    fi
}
bootoptions_backupmode_dstfile_input__sub() {
    #Define and initialize variables
    local flag_back_option_isenabled=true
    local flag_dir_isfixed=true
    local flag_show_menuitem_index_isenabled=false
    local flag_type_isdir=false
    local flag_type_isfile=true
    local flag_dir_parent_isnot_tobe_used=true

    #Initialize global variables
    tb_data_path_set=${tb_data_dstpath_set}
    tb_editmode_set="${TB_ON}"  #by default set to ON
    tb_editmode_set_off_printable="${TB_FG_RED_187}${TB_OPTIONS_INPUTMODE} (${TB_OFF}${TB_NOCOLOR})"
    tb_editmode_set_on_printable="${TB_FG_GREEN_158}${TB_OPTIONS_INPUTMODE} (${TB_ON}${TB_NOCOLOR})"
    tb_editmode_set_printable="${tb_editmode_set_off_printable}"
    # tb_keyinput_bck="${TB_EMPTYSTRING}"
    tb_keyinput_tot="${TB_EMPTYSTRING}"
    tb_listpage_start=1

    tb_path_list_arr=()
    tb_path_list_arrlen=0

    #Start loop
    while [[ 1 ]]
    do
        # #Reset global variable
        # tb_keyinput_tot="${TB_EMPTYSTRING}"

        #Print header, body, menu-options
        dircontent_data_extract_and_show__sub "${tb_data_path_set}" \
                "${tb_data_dstpath_set}" \
                "${TB_EMPTYSTRING}" \
                "${tb_listpage_start}" \
                "${TB_BACKUPMODE_DSTFILE}" \
                "${flag_back_option_isenabled}" \
                "${flag_dir_isfixed}" \
                "${flag_type_isdir}" \
                "${flag_type_isfile}" \
                "${flag_show_menuitem_index_isenabled}"

        #Take action
        dircontent_handler__sub "${tb_data_path_set}" \
                "${tb_data_dstpath_set}" \
                "${TB_BACKUPMODE_DSTFILE}" \
                "${TB_READDIALOG_CHOOSE_AN_OPTION}" \
                "${TB_READDIALOG_INPUT_FILENAME_AND_PRESS_ENTER}" \
                "${flag_back_option_isenabled}" \
                "${flag_dir_isfixed}" \
                "${flag_show_menuitem_index_isenabled}" \
                "${flag_dir_parent_isnot_tobe_used}"

        if [[ "${flag_backupmode_or_restoremode_child_exitloop}" == true ]]; then
            break
        fi
    done
}
bootoptions_backupmode_exit__sub() {
    if [[ -n "${tb_data_srcpath_set}" ]] &&  [[ -n "${tb_data_dstpath_set}" ]] &&  [[ -n "${tb_data_dstfile_set}" ]]; then
        #Update GLOBEL variable

        tb_bootoptions_set="tb_backup=${tb_data_srcpath_set};${tb_data_dstfile_set}"

        #Write 'bootoptions_set' to file
        tb_init_bootargs_tmp_write__sub "${tb_bootoptions_set}"
    fi

    #Show cursor, enable keyboard-input, enable terminal refresh
    # cursor_keyboard_termrefresh_enable__sub
}



#---SECTION: RESTORE
bootoptions_restoremode__sub() {
    #Define constants
    local PHASE_BOOTOPTIONS_RESTOREMODE_SRC_FILE=10
    local PHASE_BOOTOPTIONS_RESTOREMODE_DST_DEVPART=20
    local PHASE_BOOTOPTIONS_RESTOREMODE_COMPARE_SIZES=22
    local PHASE_BOOTOPTIONS_RESTOREMODE_EXIT=100

    #Define variables
    local phase="${PHASE_BOOTOPTIONS_RESTOREMODE_SRC_FILE}"

    #Initialize variables
    tb_data_dstpath_set="${TB_EMPTYSTRING}"
    tb_data_srcpath_set="${TB_EMPTYSTRING}"
    tb_data_dstfile_set="${TB_EMPTYSTRING}"

    #Start loop
    while [[ 1 ]]
    do
        case "${phase}" in
            "${PHASE_BOOTOPTIONS_RESTOREMODE_SRC_FILE}")
                bootoptions_restoremode_srcfile_select__sub

                if [[ "${flag_backupmode_or_restoremode_exitloop}" == true ]]; then
                    phase="${PHASE_BOOTOPTIONS_RESTOREMODE_EXIT}"
                else
                    phase="${PHASE_BOOTOPTIONS_RESTOREMODE_DST_DEVPART}"
                fi
                ;;
            "${PHASE_BOOTOPTIONS_RESTOREMODE_DST_DEVPART}")
                bootoptions_restoremode_dstpath_select__sub

                if [[ "${flag_go_back_onestep}" == true ]]; then
                    phase="${PHASE_BOOTOPTIONS_RESTOREMODE_SRC_FILE}"
                else
                    if [[ "${flag_backupmode_or_restoremode_exitloop}" == true ]]; then
                        phase="${PHASE_BOOTOPTIONS_RESTOREMODE_EXIT}"
                    else
                        phase="${PHASE_BOOTOPTIONS_RESTOREMODE_COMPARE_SIZES}"
                    fi
                fi
                ;;
            "${PHASE_BOOTOPTIONS_RESTOREMODE_COMPARE_SIZES}")
                bootoptions_restoremode_compare_disksize__sub

                if [[ "${flag_go_back_onestep}" == true ]]; then
                    phase="${PHASE_BOOTOPTIONS_RESTOREMODE_DST_DEVPART}"
                else
                    phase="${PHASE_BOOTOPTIONS_RESTOREMODE_EXIT}"
                fi
                ;;
            "${PHASE_BOOTOPTIONS_RESTOREMODE_EXIT}")
                bootoptions_restoremode_exit__sub

                break
                ;;
        esac
    done
}
bootoptions_restoremode_srcfile_select__sub() {
    #Define and initialize variables
    local flag_back_option_isenabled=false
    local flag_dir_isfixed=false
    local flag_show_menuitem_index_isenabled=true
    local flag_type_isdir=true
    local flag_type_isfile=true
    local flag_dir_parent_isnot_tobe_used=true

    #Initialize global variables
    tb_editmode_set="${TB_OFF}"
    tb_data_path_set=${tb_media_dir}
    # tb_keyinput_bck="${TB_EMPTYSTRING}"
    tb_keyinput_tot="${TB_EMPTYSTRING}"
    tb_listpage_start=1

    tb_path_list_arr=()
    tb_path_list_arrlen=0

    #Start loop
    while [[ 1 ]]
    do
        #Print header, body, menu-options
        dircontent_data_extract_and_show__sub "${tb_data_path_set}" \
                "${tb_media_dir}" \
                "${TB_EMPTYSTRING}" \
                "${tb_listpage_start}" \
                "${TB_RESTOREMODE_SRCFILE}" \
                "${flag_back_option_isenabled}" \
                "${flag_dir_isfixed}" \
                "${flag_type_isdir}" \
                "${flag_type_isfile}" \
                "${flag_show_menuitem_index_isenabled}"

        #Take action
        dircontent_handler__sub "${tb_data_path_set}" \
                "${tb_media_dir}" \
                "${TB_RESTOREMODE_SRCFILE}"  \
                "${TB_READDIALOG_CHOOSE_AN_OPTION_AND_PRESS_ENTER}" \
                "${TB_EMPTYSTRING}" \
                "${flag_back_option_isenabled}" \
                "${flag_dir_isfixed}" \
                "${flag_show_menuitem_index_isenabled}" \
                "${flag_dir_parent_isnot_tobe_used}"

        if [[ "${flag_backupmode_or_restoremode_child_exitloop}" == true ]]; then
            break
        fi
    done
}
bootoptions_restoremode_dstpath_select__sub() {
    #Define variables
    local flag_back_option_isenabled=true
    local flag_dir_isfixed=true
    local flag_show_menuitem_index_isenabled=true
    local flag_type_isdir=true
    local flag_type_isfile=false
    local flag_dir_parent_isnot_tobe_used=true

    #Initialize global variables
    tb_editmode_set="${TB_OFF}"
    tb_data_path_set=${tb_dev_dir}
    # tb_keyinput_bck="${TB_EMPTYSTRING}"
    tb_keyinput_tot="${TB_EMPTYSTRING}"
    tb_listpage_start=1

    tb_path_list_arr=()
    tb_path_list_arrlen=0

    #Start loop
    while [[ 1 ]]
    do
        #Print header, body, menu-options
        dircontent_data_extract_and_show__sub "${tb_data_path_set}" \
                "${tb_dev_dir}" \
                "${TB_PATTERN_MMCBLK0}" \
                "${tb_listpage_start}" \
                "${TB_RESTOREMODE_DSTPATH}" \
                "${flag_back_option_isenabled}" \
                "${flag_dir_isfixed}" \
                "${flag_type_isdir}" \
                "${flag_type_isfile}" \
                "${flag_show_menuitem_index_isenabled}"

        #Take action
        dircontent_handler__sub "${tb_data_path_set}" \
                "${tb_dev_dir}" \
                "${TB_RESTOREMODE_DSTPATH}"  \
                "${TB_READDIALOG_CHOOSE_AN_OPTION_AND_PRESS_ENTER}" \
                "${TB_EMPTYSTRING}" \
                "${flag_back_option_isenabled}" \
                "${flag_dir_isfixed}" \
                "${flag_show_menuitem_index_isenabled}" \
                "${flag_dir_parent_isnot_tobe_used}"

        if [[ "${flag_backupmode_or_restoremode_child_exitloop}" == true ]]; then
            break
        fi
    done
}
bootoptions_restoremode_compare_disksize__sub() {
    #Note: this subroutine passes the result to the global variable 'tb_disksizes_compare_result'
    diskspaces_compare__func "${tb_data_srcpath_set}" "${tb_data_dstpath_set}" "${TB_TYPE_RESTORE}"

    if [[ "${tb_disksizes_compare_result}" == "${TB_DISKSIZE_COMPARE_RESULT_SUFFICIENT}" ]]; then
        flag_go_back_onestep=false
    else    #tb_disksizes_compare_result = TB_DISKSIZE_COMPARE_RESULT_INSUFFICIENT
        flag_go_back_onestep=true
    fi
}
bootoptions_restoremode_exit__sub() {
    if [[ -n "${tb_data_srcpath_set}" ]] &&  [[ -n "${tb_data_dstpath_set}" ]]; then
        #Update GLOBEL variable

        tb_bootoptions_set="tb_restore=${tb_data_srcpath_set};${tb_data_dstpath_set}"

        #Write 'bootoptions_set' to file
        tb_init_bootargs_tmp_write__sub "${tb_bootoptions_set}"
    fi

    #Show cursor, enable keyboard-input, enable terminal refresh
    # cursor_keyboard_termrefresh_enable__sub
}



#---SECTION: DISABLE
bootoptions_disable__sub() {
    #Remove file (if present)
    remove_file__func "${tb_init_bootargs_tmp_fpath}"
}



#---SECTION: ISPBOOOT.BIN BOOT-SEQUENCE
ispboootbin_bootseqmenu__sub() {
    #Print header
    tibbo_print_title__sub    

    #Print bootinto menutitle
    ispboootbin_bootseqmenu_title_print__sub

    #Print body
    ispboootbin_bootseqmenu_body_print__sub

    #Show read-dialog (loop)
    #Note: result is passed to global variable 'tb_ispboootbin_bootseq_mychoice'
    ispboootbin_bootseqmenu_readdialog_choice__sub

    #Take action
    ispboootbin_bootseqmenu_readdialog_action__sub
}
ispboootbin_bootseqmenu_title_print__sub() {
    print_duplicate_char__func "${TB_DASH}" "${TB_TABLEWIDTH}" "${TB_NOCOLOR}"
    print_leading_trailing_strings_on_opposite_sides__func "${TB_TITLE_ISPBOOOTBIN_BOOTSEQ}" \
            "${TB_EMPTYSTRING}" \
            "${TB_TABLEWIDTH}"
    print_duplicate_char__func "${TB_DASH}" "${TB_TABLEWIDTH}" "${TB_NOCOLOR}"
}
ispboootbin_bootseqmenu_body_print__sub() {
    #Define and initialize variables
    local print_menuitem_1="${TB_FG_GREY_246}${TB_MODE_ISPBOOOTBIN_BOOTSEQ_SDUSB0USB1}${TB_NOCOLOR}"
    local print_menuitem_2="${TB_FG_GREY_246}${TB_MODE_ISPBOOOTBIN_BOOTSEQ_SDUSB1USB0}${TB_NOCOLOR}"
    local print_menuitem_3="${TB_FG_GREY_246}${TB_MODE_ISPBOOOTBIN_BOOTSEQ_USB0SDUSB1}${TB_NOCOLOR}"
    local print_menuitem_4="${TB_FG_GREY_246}${TB_MODE_ISPBOOOTBIN_BOOTSEQ_USB0USB1SD}${TB_NOCOLOR}"
    local print_menuitem_5="${TB_FG_GREY_246}${TB_MODE_ISPBOOOTBIN_BOOTSEQ_USB1SDUSB0}${TB_NOCOLOR}"
    local print_menuitem_6="${TB_FG_GREY_246}${TB_MODE_ISPBOOOTBIN_BOOTSEQ_USB1USB0SD}${TB_NOCOLOR}"

    #Extract 'ispboootbin bootseq' information
    extract_ispboootbin_bootseq_info__func

    #Update variables (if appliable)
    case "${tb_ispboootbin_bootseq_set}" in
        "${TB_MODE_ISPBOOOTBIN_BOOTSEQ_SDUSB0USB1}")
            print_menuitem_1="${tb_ispboootbin_bootseq_printable}"
            ;;
        "${TB_MODE_ISPBOOOTBIN_BOOTSEQ_SDUSB1USB0}")
            print_menuitem_2="${tb_ispboootbin_bootseq_printable}"
            ;;
        "${TB_MODE_ISPBOOOTBIN_BOOTSEQ_USB0SDUSB1}")
            print_menuitem_3="${tb_ispboootbin_bootseq_printable}"
            ;;
        "${TB_MODE_ISPBOOOTBIN_BOOTSEQ_USB0USB1SD}")
            print_menuitem_4="${tb_ispboootbin_bootseq_printable}"
            ;;
        "${TB_MODE_ISPBOOOTBIN_BOOTSEQ_USB1SDUSB0}")
            print_menuitem_5="${tb_ispboootbin_bootseq_printable}"
            ;;
        "${TB_MODE_ISPBOOOTBIN_BOOTSEQ_USB1USB0SD}")
            print_menuitem_6="${tb_ispboootbin_bootseq_printable}"
            ;;
    esac

    #Print
    print_menuitem__func "${TB_FOURSPACES}" \
            "${TB_ITEMNUM_1}" \
            "${print_menuitem_1}" \
            "${TB_EMPTYSTRING}"
    print_menuitem__func "${TB_FOURSPACES}" \
            "${TB_ITEMNUM_2}" \
            "${print_menuitem_2}" \
            "${TB_EMPTYSTRING}"
    print_menuitem__func "${TB_FOURSPACES}" \
            "${TB_ITEMNUM_3}" \
            "${print_menuitem_3}" \
            "${TB_EMPTYSTRING}"
    print_menuitem__func "${TB_FOURSPACES}" \
            "${TB_ITEMNUM_4}" \
            "${print_menuitem_4}" \
            "${TB_EMPTYSTRING}"
    print_menuitem__func "${TB_FOURSPACES}" \
            "${TB_ITEMNUM_5}" \
            "${print_menuitem_5}" \
            "${TB_EMPTYSTRING}"
    print_menuitem__func "${TB_FOURSPACES}" \
            "${TB_ITEMNUM_6}" \
            "${print_menuitem_6}" \
            "${TB_EMPTYSTRING}"
    print_duplicate_char__func "${TB_DASH}" "${TB_TABLEWIDTH}" "${TB_NOCOLOR}"
    print_menuitem__func "${TB_FOURSPACES}" \
            "${TB_OPTIONS_M}" \
            "${TB_OPTIONS_MAIN}" \
            "${TB_EMPTYSTRING}"
    print_menuitem__func "${TB_FOURSPACES}" \
            "${TB_OPTIONS_Q}" \
            "${TB_OPTIONS_QUIT_CTRL_C}" \
            "${TB_EMPTYSTRING}"
    print_duplicate_char__func "${TB_DASH}" "${TB_TABLEWIDTH}" "${TB_NOCOLOR}"
}
ispboootbin_bootseqmenu_readdialog_choice__sub() {
    while [[ 1 ]]
    do
        #Select an option
        read -N1 -r -p "${TB_READDIALOG_CHOOSE_AN_OPTION}" tb_ispboootbin_bootseq_mychoice

        #Only continue if a valid option is selected
        if [[ ! -z ${tb_ispboootbin_bootseq_mychoice} ]]; then
            if [[ ${tb_ispboootbin_bootseq_mychoice} =~ ${TB_ISPBOOOTBIN_BOOTSEQ_MYCHOICE_REGEX} ]]; then
                movedown_and_clean__func "${TB_NUMOFLINES_1}"

                break
            else
                if [[ ${tb_ispboootbin_bootseq_mychoice} == ${TB_ENTER} ]]; then
                    moveup_and_clean__func "${TB_NUMOFLINES_1}"                    
                else
                    moveup_and_clean__func "${TB_NUMOFLINES_0}"
                fi

                # readdialog_clean_buffer__func
            fi
        else
            moveup_and_clean__func "${TB_NUMOFLINES_0}"

            # readdialog_clean_buffer__func
        fi
    done
}
ispboootbin_bootseqmenu_readdialog_action__sub() {
    #Remove file starting with pattern '.tb_init_bootseq_*'
    remove_file__func "${tb_init_bootseq_sdusb0usb1_fpath}"
    remove_file__func "${tb_init_bootseq_sdusb1usb0_fpath}"
    remove_file__func "${tb_init_bootseq_usb0sdusb1_fpath}"
    remove_file__func "${tb_init_bootseq_usb0usb1sd_fpath}"
    remove_file__func "${tb_init_bootseq_usb1sdusb0_fpath}"
    remove_file__func "${tb_init_bootseq_usb1usb0sd_fpath}"

    #Create file based on the selection
    local targetfpath="${TB_EMPTYSTRING}"
    case "${tb_ispboootbin_bootseq_mychoice}" in
        "1")
            targetfpath="${tb_init_bootseq_sdusb0usb1_fpath}"
            ;;
        "2")
            targetfpath="${tb_init_bootseq_sdusb1usb0_fpath}"
            ;;
        "3")
            targetfpath="${tb_init_bootseq_usb0sdusb1_fpath}"
            ;;
        "4")
            targetfpath="${tb_init_bootseq_usb0usb1sd_fpath}"
            ;;
        "5")
            targetfpath="${tb_init_bootseq_usb1sdusb0_fpath}"
            ;;
        "6")
            targetfpath="${tb_init_bootseq_usb1usb0sd_fpath}"
            ;;
        *)
            #Do nothing
            ;;
    esac

    #Write to file
    touch "${targetfpath}" 2>/dev/null
}



#---SECTION: REBOOT
reboot__sub() {
    #Define variables
    local keyinput="${TB_OPTIONS_N}"

    #Move-down one line
    movedown_and_clean__func "${TB_NUMOFLINES_1}"

    #Show read-dialog
    while [[ 1 ]]
    do
        #Select an option
        read -N1 -r -p "${TB_READDIALOG_ARE_YOU_SURE_YOU_WISH_TO_REBOOT}" keyinput
        # movedown_and_clean__func "${TB_NUMOFLINES_1}"

        #Only continue if a valid option is selected
        if [[ ! -z ${keyinput} ]]; then
            if [[ ${keyinput} =~ ${TB_YN_REGEX} ]]; then
                movedown_and_clean__func "${TB_NUMOFLINES_1}"

                break
            else
                if [[ ${keyinput} == ${TB_ENTER} ]]; then
                    moveup_and_clean__func "${TB_NUMOFLINES_1}"                    
                else
                    moveup_and_clean__func "${TB_NUMOFLINES_0}"
                fi

                # readdialog_clean_buffer__func
            fi
        else
            moveup_and_clean__func "${TB_NUMOFLINES_0}"

            # readdialog_clean_buffer__func
        fi
    done

    if [[ "${keyinput}" == "${TB_OPTIONS_Y}" ]]; then
        movedown_and_clean__func "${TB_NUMOFLINES_1}"
        
        ${REBOOT_CMD}
    fi
}



#---MAIN SUBROUTINE
main__sub() {
    mainmenu_checkif_user_is_root__func

    while [[ 1 ]]
    do
        #Print header
        tibbo_print_title__sub

        #Extract info from files
        mainmenu_extract_info__func

        #Print main-menu title
        mainmenu_print_title__sub

        #Print body
        mainmenu_print_body__sub

        #Print legend
        mainmenu_print_legend__sub

        #Print remark (if any)
        mainmenu_print_remark__sub

        #Show read-dialog (loop)
        #Note: result is passed to global variable 'tb_mainmenu_mychoice'
        mainmenu_readdialog_choice__sub

        #Take action
        mainmenu_readdialog_action__sub
    done
}



#---EXECUTE
main__sub
